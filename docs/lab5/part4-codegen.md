## 代码生成

为了能够随时对就变量进行修改和引用，我们需要把局部变量保存在某个能够随时访问的地方，并记住他们的确切位置。简单起见，我们会把它们保存在栈上。

如何在编译时知道一个变量的位置呢？绝对的内存地址要到运行时才能确定，结合栈帧的知识，编译时我们可以通过`fp`以及固定的偏移来获取特定变量。

### 建立栈帧

当一个函数(我们称它为`f`)返回时，它的调用者需要能够接上它离开的地方。这意味着它的栈帧，以及`sp`和`fp`中的值，都需要和`f`被调用之前完全一样。被调用时，`f`需要做的第一件事就是为自己建立一个新的栈帧，使用下面的指令(不妨自己用 gcc 编译一个稍复杂的程序，看看结果)。

```
addi sp, sp, -framesize         #建立栈帧
sw ra, framesize-4(sp)          #储存返回地址（已经储存在 ra 中，为什么再次储存？）
sw fp, framesize-8(sp)        #储存 fp
addi fp, sp, framesize          #更新 fp
```

这些指令称为函数前序（function prologue）。目前, framesize = 变量数量 * 4 + 8（为什么？），注意，我们所有的变量长度都为4。

在`f`返回之前，它立即执行函数前序来删除这个栈帧，让一切都和函数前序执行之前一样。

```
lw fp, framesize-8(sp)         #恢复 fp
lw ra, framesize-4(sp)          #恢复 ra
addi sp, sp, framesize          #恢复 sp
ret
```
这被称为函数收尾（function epilogue）。到目前为止，我们可以不需要函数前序（function prologue）或函数收尾（function epilogue），但添加它们将减少后续面对跳转和函数时的困难。

有了这些准备：
- 我们可以安全地将局部变量推送到栈上，而不改变调用者的栈帧。
- **可以将变量位置保存为`fp`的偏移量**。我们知道`fp`到`sp`上面没有任何东西（因为我们在函数前序中设置了一个空的堆栈框架），而且我们知道`fp`在函数收尾之前不会改变。


我们应该在函数定义的开始处生成函数前序，就在函数的标签之后，并在函数末尾生成函数收尾。

需要注意的是，我们需要改写之前我们的 RET 指令，它应当跳到函数收尾而不是直接 ret，考虑到目前我们没有分支指令而且只有一个函数，不改写暂时不会产生问题。

这样，我们对于变量的映射可以通过变量相对于 `fp` 的偏移来建立。现在让我们看看如何处理变量的声明、赋值和引用。

### 变量声明

碰到变量声明时，需将变量保存到栈中并设定它的偏移量。事实上，我们在函数前序中留下了变量的位置（注意栈帧的大小），也就隐式的“保存”了变量。首先我们需要一个数据结构来维护变量的信息，如：名称、类型（lab11）、声明位置、初始化语句等。至于偏移，你可以把偏移直接作为变量的属性，也可以建立一个变量到其偏移的映射，关键的问题是偏移量的确定。

目前阶段，你可以简单的使用一个简单的链表或者数组来保存已声明变量的信息。

#### 偏移量确定

变量的偏移量有一种比较暴力的设定方式：每一个声明的变量偏移依次递增。目前我们没有作用域，这样做是没问题的，但在第7章引入作用域后，这种暴力的实现会出现一些问题。

> 变量重复声明的检查：每次碰到生命则检查有无同名变量已经声明。

### 变量赋值

#### 代码生成

目前只有变量才能作为左值，所以记得检查 assign 操作的类型（或许你已经在 parser 中进行了检查）。因为我们的变量相当于一个地址，可以通过 `sd` 指令完成变量赋值。

```
visitAssign(Node assign) {
    visit(assign.rhs);                  //计算变量值，结果压入栈中
    emitStore(assign.lhs.offset);       //进行赋值
}
```
`void emitStore(int offset)` 生成如下代码：

```asm
lw t0, 0(sp)
addi sp, sp, 4                     #pop 变量值                   
sw t0, 4*{offset}(fp)              #变量赋值
addi sp, sp, -4
sw t0, 0(sp)                       #push 变量值，因为 assign 语句是有返回值的
```

显然，这段代码可以优化，不做赘述。

> 注意，assign 语句存在返回值，也就会最终在栈中留下一个值。
> 因此， `a = 0;` 语句会给 `a` 赋值并在栈中留下一个 `0`，必须将这个多余的值弹出。
> \<statement\> ::= \<expr\> ";" 类型的 statement 都存在这个问题。

### 变量引用

要引用表达式中的变量，只需将其从堆栈中复制到栈顶即可：

```
visitVar(Node var) {
    emitLoad(var.offset);
}
```

emitLoad(var.offset)：

```asm
lw t0, 4*{offset}(fp)           #取变量的值
addi sp, sp, 4
sw t0, 0(sp)                    #push到栈顶
```
