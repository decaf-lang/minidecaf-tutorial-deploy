{"./":{"url":"./","title":"实验简介","keywords":"","body":"MiniDecaf 编译实验 实验概述 MiniDecaf 1 是一个 C 的子集，去掉了如 include/define/多文件/struct 等特性。 这学期的编译实验要求同学通过多次“思考-实现-重新设计”从简单到相对复杂的Minidecaf语言的完整编译器， 能够把 MiniDecaf 代码编译到 RISC-V 汇编。 从而能够理解并解决编译真实的程序设计语言时遇到的问题，并能与编译的原理进行对照。 下面是 MiniDecaf 的快速排序，和 C 是一样的 int qsort(int *a, int l, int r) { int i = l; int j = r; int p = a[(l+r)/2]; while (i p) j = j - 1; if (i > j) break; int u = a[i]; a[i] = a[j]; a[j] = u; i = i + 1; j = j - 1; } if (i l) qsort(a, l, j); } 如目录所示，MiniDecaf 实验分为六大阶段，由十二个小步骤组成。 每个步骤，你的任务都是把 MiniDecaf 程序编译到 RISC-V 汇编，并能在QEMU硬件模拟器上运行。 每步做完以后，你都有一个完整能运行的编译器。 随着实验一步一步进行，MiniDecaf 语言会从简单变复杂，每步都会增加部分的语言特性。 实验的关键目标是理解和掌握编译器的设计与实现方法，并能与编译原理课程的知识互补与相互印证。 我们提供一系列的参考实现，包含 Python/Rust/Java/C++ 的。 同学遇到困难可以分析了解参考实现、也可以复用他们的代码。不论同学采用那种方式，都希望能达到实验目标。 编译器边边角角的情况很多，所以你的实现只要通过我们的测例就视为正确。 实验提交 你需要使用 git 对你的实验做版本维护，然后提交到 git.tsinghua.edu.cn。 大家在网络学堂提交帐号名后，助教给每个人会建立一个私有的仓库，作业提交到那个仓库即可。 关于 git 使用，大家也可以在网上查找资料。 每次除了实验代码，你还需要提交 实验报告，其中包括 指导书里面思考题的回答 声明你参考以及复用了谁的代码 晚交扣分规则 是： 晚交 n 天，则扣除 n/15 的分数，扣完为止。例如，晚交三天，那你得分就要折算 80%。 备注 1. 关于名字由来，往年实验叫 Decaf，所以今年就叫 MiniDecaf 了。不过事实上现在的 MiniDecaf 和原来的 Decaf 没有任何关系。 ↩ "},"docs/log.html":{"url":"docs/log.html","title":"更新日志","keywords":"","body":"更新日志 2020.08.29：讨论准备实验帮助文档的改进，开始进行实验帮助文档v0.2 2020.08.26：完成实验帮助文档v0.1，进行文档review 2020.08.19：讨论准备实验帮助文档和分工 2020.08.15：各位助教基于不同的编程语言进一步完善改进基于v2的step1-12 2020.08.05：大致确定实验方案，确定目标语言的语法规范v2，设计基于v2的step1-12 2020.08.01：开始进行基于目标语言的语法规范v1的step，部分助教基于不同编程语言完成基于v1的step1~15的大部分 2020.07.29：大致确定实验方案，不限定实现编译器的编程语言和词法/语法解析方法，确定目标语言的语法规范v1，设计基于v1的step1-15，设定汇编语言 2020.07.20：minidecaf实验准备，方案设计 "},"docs/lab0/env.html":{"url":"docs/lab0/env.html","title":"环境配置","keywords":"","body":"环境配置 必做：RISC-V 的 gcc 和 qemu 我们的编译器只生成 RISC-V 汇编，但是提供预编译的 gcc 和 qemu 模拟器。 gcc 用来把 C 编译到汇编、以及把汇编变成 RISC-V 可执行文件；qemu 用来运行 RISC-V 可执行文件。 不过我们提供的 gcc 和 qemu 只能在 Linux/Mac 下运行，Windows 的同学 可以使用 WSL，或者运行一个虚拟机。 关于 WSL / 虚拟机使用，以及 Linux 基础操作，大家可以自己在网上查找资料。 你的编译器 gcc qemu MiniDecaf 源文件 ------------> RISC-V 汇编 -----> 可执行文件 --------> 输出 这一步的环境配置指南 Windows 用户 暂不支持 Windows，请自行配置好 WSL / 虚拟机。 Linux 用户 从网络学堂下载 riscv-prebuilt.tar.gz 压缩包并解压（命令是 tar xzf riscv-prebuilt.tar.gz） 安装工具链 cp riscv-prebuilt/* /usr/ -r 在第 2. 步，你可以选择不安装到系统目录下。相应的，你需要设置环境变量： export PATH=$PATH:/path/to/riscv-prebuilt/bin，把 /path/to 替换为你的解压目录 执行下面命令测试你 gcc 和 qemu 是否成功安装 1： 创建 test.c 文件，其中写入如下内容 #include int main() { printf(\"Hello world!\\n\"); } 编译 test.c 文件，gcc 应该输出一个可执行文件 a.out。但 a.out 是 RISC-V 可执行文件，所以我们的 X86 计算机无法运行。 $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 -S test.c $ ls a.out a.out $ ./a.out bash: ./a.out: cannot execute binary file: Exec format error 使用 qemu 执行 a.out $ qemu-riscv32 a.out Hello world! macOS 用户 从这里下载预编译好的 RISC-V 工具链并解压。 由于 macOS 不支持 QEMU 的用户态模式，我们使用 Spike 模拟器和一个简易内核 riscv-pk 提供用户态程序的运行环境。网络学堂上提供了我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz。你也可以使用 Homebrew 安装 Spike 2： $ brew tap riscv/riscv $ brew install riscv-isa-sim （可选）设置环境变量，以便每次使用时不需要输入完整路径。 测试你 GCC 和 Spike 是否成功安装，详见RISC-V 的工具链使用。 推荐：参考实现的环境 我们强烈推荐你选择一个参考实现，并且先测试运行（见下一节）一下，为此你需要配置参考实现的环境。 现在已有如下的参考实现，请根据自己的喜好选择一个，git clone 到本地，然后按照它的 README 配置好它的环境。 Python-ANTLR 地址 https://github.com/decaf-lang/minidecaf/tree/md-dzy clone 命令：git clone git@github.com:decaf-lang/minidecaf.git -b md-dzy Rust-lalr1 地址 https://github.com/decaf-lang/minidecaf/tree/mashplant clone 命令：git clone git@github.com:decaf-lang/minidecaf.git -b mashplant Rust-manual 地址 https://github.com/decaf-lang/minidecaf/tree/md-cy clone 命令：git clone git@github.com:decaf-lang/minidecaf.git -b md-cy Java-ANTLR 地址 https://github.com/decaf-lang/minidecaf/tree/md-xxy clone 命令：git clone git@github.com:decaf-lang/minidecaf.git -b md-xxy C++-ANTLR 有两个，第一个： 地址 https://github.com/decaf-lang/minidecaf/tree/md-tsz clone 命令：git clone git@github.com:decaf-lang/minidecaf.git -b md-tsz 第二个： 地址 https://github.com/decaf-lang/minidecaf/tree/md-zj clone 命令：git clone git@github.com:decaf-lang/minidecaf.git -b md-zj C++-manual 地址 https://github.com/decaf-lang/minidecaf/tree/md-zyr clone 命令：git clone git@github.com:decaf-lang/minidecaf.git -b md-zyr 备注 1. 开头的 $ 表示接下来是一条命令，记得运行的时候去掉 $。例如，让你运行 $ echo x，那你最终敲到终端里的是 echo x（然后回车）。如果开头没有 $，那么这一行是上一条命令的输出（除非我们特别说明，这一行是你要输入的内容）。 ↩ 2. Homebrew 也提供了 riscv-pk，不过那是 64 位的，而我们预编译的是 32 位的。 ↩ "},"docs/lab0/testing.html":{"url":"docs/lab0/testing.html","title":"运行测试样例","keywords":"","body":"运行测试样例 测试相关的文件在 minidecaf-tests 里面，其中 examples/ 是各个步骤的输入输出，测试脚本是 check.sh。 测试的运行步骤 如下 用 git clone 把 minidecaf-tests 和一个参考实现克隆到同一个目录下面。 进入 minidecaf-tests/，修改 check.sh 的 gen_asm，根据你选择的参考代码反注释某条命令 [可选] sudo apt install parallel 安装 parallel 以便并行测试，测试时间可缩短百分之七八十 [可选] 修改 check.sh 里面的 JOBS，控制要运行哪些测试点 运行 ./check.sh 即可。 测试运行的 输出结果 如下，OK 表示通过，FAIL 表示输出不对，ERR 表示编译错误。 $ ./check.sh gcc found qemu found parallel found OK testcases/step1/multi_digit.c OK testcases/step1/newlines.c ...... 其他测试点，太长省略 OK testcases/step12/matmul.c OK testcases/step12/quicksort.c "},"docs/lab0/riscv.html":{"url":"docs/lab0/riscv.html","title":"RISC-V 的工具链使用","keywords":"","body":"RISC-V 相关信息 RISC-V 是一个 RISC 指令集架构，你实现的编译器要编译到 RISC-V 汇编。 指令集文档在这里，我们只需要其中的 \"Unprivileged Spec\"。 RISC-V 工具使用 我们提供预先编译好的 RISC-V 工具，在环境配置中已经叙述了安装和使用方法。 下面汇总一下。 注意，我们虽然是用的工具前缀是 riscv64， 但我们加上参数 -march=rv32im -mabi=ilp32 以后就能编译到 32 位汇编 1。 使用时记得加这个参数，否则默认编译到 64 位汇编。 gcc 编译 input.c 到汇编 input.s，最高优化等级 # input.c 的内容 $ cat input.c int main(){return 233;} # 编译到 input.s $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 -S input.c # gcc 的编译结果 $ cat input.s .file \"input.c\" .option nopic .attribute arch, \"rv32i2p0_m2p0\" .attribute unaligned_access, 0 .attribute stack_align, 16 .text .section .text.startup,\"ax\",@progbits .align 2 .globl main .type main, @function main: li a0,233 ret .size main, .-main .ident \"GCC: (SiFive GCC 8.3.0-2020.04.0) 8.3.0\" gcc 编译 input.s 到可执行文件 a.out # input.s 的内容，就是上面汇编输出的简化版本 $ cat input.s .text .globl main main: li a0,233 ret # 编译到 a.out $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 input.s # 输出结果，能看到是 32 位的 RISC-V 可执行文件 $ file a.out a.out: ELF 32-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped *【Linux 用户】qemu 运行 a.out，获取返回码 # 运行 a.out $ qemu-riscv32 a.out # $? 是 qemu 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 *【macOS 用户】Spike 模拟器运行 a.out，获取返回码 # 运行 a.out $ spike --isa=RV32G /path/to/pk a.out bbl loader # $? 是 spike 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 1. 这里的 rv32im 表示使用 RV32I 基本指令集，并包含 M 扩展（乘除法）。本实验中我们不需要其他扩展。 ↩ "},"docs/lab1/part1.html":{"url":"docs/lab1/part1.html","title":"从零开始的 lexer、parser 以及汇编生成","keywords":"","body":"实验指导 step1：词法分析、语法分析、目标代码生成 第一个步骤中，MiniDecaf 语言的程序就只有 main 函数，其中只有一条语句，是一条 return 语句，并且只返回一个整数（非负常量），如 int main() { return 233; }。 第一个步骤，我们的任务是把这样的程序翻译到汇编代码。 不过，比起完成这个任务，更重要的是你能 知道编译器包含哪些阶段，并且搭建起后续开发的框架 了解一大堆基本概念、包括 词法分析、语法分析、语法树、栈式机模型、中间表示 学会开发中使用的工具和设计模式，包括 gcc/qemu、词法语法分析工具 和 Visitor 模式* 词法分析 读内容 *词法分析* MiniDecaf 源文件 --------> 字节流 ----------> Tokens --> ...... --> RISC-V 汇编 词法分析（lexical analysis） 是我们编译器的第一个阶段，实现词法分析的代码称为 lexer ， 也有人叫 scanner 或者 tokenizer。 它的输入 是源程序的字节流 如 \"\\x69\\x6e\\x74\\x20\\x6d\\x61\\x69\\x6e\\x28\\x29\\x7b\\x72\\x65\\x74\\x75\\x72\\x6e\\x20\\x30\\x3b\\x7d\"。 上面的其实就是 \"int main(){return 0;}\"。 它的输出 是一系列 词（token） 组成的流（token stream）1 上面的输入，经过 lexer 以后输出如 [关键字(int)，空白、标识符(main)，左括号，右括号，左花括号，关键字(return)，空白、整数(0)，分号，右花括号]。 如果没有词法分析，编译器看到源代码中的一个字符 '0'，都不知道它是一个整数的一部分、还是一个标识符的一部分，那就没法继续编译了。 为了让 lexer 完成把字节流变成 token 流的工作，我们需要告诉它 有哪几种 token 如上，我们有：关键字，标识符，整数，空白，分号，左右括号花括号这几种 token token 种类 和 token 是不一样的，例如 Integer(0) 和 Integer(222) 不是一个 token，但都是一种 token：整数 token。 对于每种 token，它能由哪些字节串构成 例如，“整数 token” 的字节串一定是 “包含一个或多个 '0' 到 '9' 之间的字节串”。 不过这没考虑负数，后面 “语义检查” 会继续讨论。 词法分析的正经算法会在理论课里讲解，但我们可以用暴力算法实现一个 lexer。 例如我们实现了一个 minilexer（代码）当中， 用一个包含所有 token 种类的列表告诉 lexer 有哪几种 token（上面第 1. 点）， 对每种 token 用正则表达式描述它能被那些字节串构成（上面第 2. 点）。 细化到代码，Lexer 的构造函数的参数就包含了所有 token 种类。 例如其中的 TokenType(\"Integer\", f\"{digitChar}+\", ...) 就定义了 Integer 这种 token， 并且要求每个 Integer token 的字符串要能匹配正则表达式 [0-9]+，和上面第 2. 点一样。 你可尝试运行 minilexer，运行结果如下（我们忽略了空白） $ python3 minilexer.py token kind text Int int Identifier main Lparen ( Rparen ) Lbrace { Return return Integer 123 Semicolon ; Rbrace } 本质上，token 是上下文无关语法的终结符，词法分析就是把一个字节串转换成上下文无关语法的 终结符串 的过程。 不过 token 比单纯的终结符多一个属性，就是它的字符串（如 Identifier(main) 的 main），你可以说 token 是有标注的终结符。 语法分析 词法分析 *语法分析* 字节流 ----------> Tokens ----------> 语法树 --> ...... --> RISC-V 汇编 语法分析（syntax analysis） 是紧接着词法分析的第二个阶段，实现语法分析的代码称为 parser 。 它的输入 是 token 流 就是 lexer 的输出，例子上面有 如果输入没有语法错误，那么 它的输出 是一颗 语法树（syntax tree） 比如上面的程序的语法树类似 编译原理的语法树就类似自动机的 语法分析树，不同的是语法树不必表示出实际语法中的全部细节。 例如上图中，几个表示括号的结点在语法树中是可以省略的。 语法分析在词法分析的基础上，又把程序的语法结构展现出来。 有了语法分析，我们才知道了一个 Integer(0) token 到底是 return 的参数、if 的条件还是参与二元运算。 为了完成语法分析，肯定要描述程序语言的语法，我们使用 上下文无关语法 描述 MiniDecaf。 就这一步来说，MiniDecaf 的语法很简单，产生式大致如下，起始符号是 program。 program : function function : type Identifier Lparen Rparen Lbrace statement Rbrace type : Int statement : Return expression Semicolon expression : Integer 一些记号的区别： 形式语言与自动机课上，我们用大写字母表示非终结符，小写字母表示终结符。 这里正好相反，大写字母开头的是终结符，小写字母开头的是非终结符。 并且我们用 : 而不是 -> 隔开产生式左右两边。 同样的，语法分析的正经算法会在课上讲到。 但我们实现了一个暴力算法 miniparser（代码）。 这个暴力算法不是通用的算法，但它足以解析上述语法。 你可尝试运行，运行结果如下（下面输出就是语法树的先序遍历） $ python3 miniparser.py program(function(type(Int), Identifier(main), Lparen, Rparen, Lbrace, statement(Return, expression(Integer(123)), Semicolon), Rbrace)) 前面提到，语法树可以不像语法分析树那样严格。 如果语法树里面抽象掉了程序的部分语法结构，仅保留底下的逻辑结构，那样的语法树可以称为 抽象语法树（AST, abstract syntax tree）；而和语法完全对应的树称为 具体语法树。 当然，AST 和语法树的概念没有清楚的界限，它们也常常混用，不必扣概念字眼。 上面 miniparser 的输出就是一颗具体语法树，而它的抽象语法树可能长成下面这样（取决于设计） $ python3 miniparser-ast.py # 假设有个好心人写了 miniparser-ast.py Prog(funcs=[ Func(name=\"main\", type=(\"int\", []), body=[ ReturnStmt(value=Integer(123)) ]) ]) 语义检查 有时我们会用 语法检查 这个词，因为语法分析能发现输入程序的语法错误。 对应语法检查，还有一个词叫 语义检查。 它检查源程序是否满足 语义规范，是否有 语义错误，例如类型错误、使用未定义变量、重复定义等等。 就 step1 来说，我们的语义规范如下。显然，我们要检查的就只是 Integer 字面量没有越界。 1.1. MiniDecaf 的 int 类型具体指 32 位有符号整数类型，范围 [-2147483648, 2147483647]，补码表示。 1.2. 编译器应当只接受 [0, 2147483647] 范围内的整数（step2 会添加负数支持）。 如果整数超过此范围，编译器应当报错。 1.3. 因为只有一个函数，故函数名必须是 main。 完整的语义规范应包含如下几点。指导书只会包含关键点，避免叙述太冗长。 什么样的代码是 不合法 的。对于不合法的代码，编译器必须报错而不是生成汇编。 例如 step1 中，如果程序中 int 字面量超过上面的范围，那编译器就应该报错 \"int too large\"。 如果函数名不是 main，也应该报错。 合法程序中，每个操作的行为应该是什么样的。 例如 return 执行结果是：对操作数求值并作为返回值，然后终止当前函数执行、返回 caller 或完成程序执行。 对于合法程序，你生成的汇编须和 gcc 生成的汇编运行结果一致。 什么样的行为是 未定义 的。如果代码在运行时展现未定义行为，编译器不用报错，但它后果是不确定的。 例如有符号整数溢出、数组越界、除以零都是未定义行为。 测例代码不会有未定义行为，不必费心考虑。 语义检查的实现方式很灵活，可以实现成单独的一个阶段，也可以嵌在其他阶段里面。 第一种方式在后面的实验中有，但就 step1 而言，检查 int 范围的工作直接放进 parser 或 lexer 中就行了。 例如我们就把他放到了下一个阶段：目标代码生成里。 目标代码生成 词法分析 语法分析 *目标代码生成* 字节流 ----------> Tokens ----------> 语法树 ----------------> RISC-V 汇编 生成 AST 以后，我们就能够生成汇编了，所以 目标代码生成（target code emission） 是第三也是最后一个步骤，这里目标代码就指 RISC-V 汇编。 它的输入 是一颗 AST 它的输出 是汇编代码 这一步中，为了生成代码，我们只需要 遍历 AST，找到 return 语句对应的 stmt 结点，然后取得 return 的值, 设为 X 2 [可选] 语义检查，若 X 不在 [-2147483648, 2147483647] 中则报错；并且检查函数名是否是 main。 打印一个返回 X 的汇编程序 针对第 1. 点，我们使用一个 Visitor 模式来完成 AST 的遍历。 同样，我们有一个 minivisitor（代码）作为这个阶段的例子。 Visitor 模式比简单的递归函数更强大，用它可以让以后的步骤更方便。 Visitor 模式速成请看 这里 针对第 2. 点，我们用 (RISC-V) gcc 编译一个 int main(){return 233;} 就能知道这个汇编程序什么样。 gcc 的输出可以简化，去掉一些不必要的汇编指令以后，这个汇编程序长成下面这样。 编译方法请看 工具链使用。 汇编代码中，li 加载常数 X 到 a0 寄存器。RISC-V 约定 a0 保存返回值，之后 ret 就完成了 return X 的工作。 .text .globl main main: li a0,X ret 运行 minivisitor，输出就是模板中的 X 被替换为了一个具体整数 $ python minivisitor.py .text .globl main main: li a0,123 ret 至此，我们的编译器就完成了，它由三个阶段构成：词法分析、语法分析、目标代码生成。 每个阶段都有自己的任务，并且阶段和阶段之间的接口很明确：字节流、token 流、AST、汇编代码。 任务 在不同输入上，运行 minilexer, miniparser 和 minivisitor。 浏览它们的代码（不用完全看懂） 思考题 以下思考题六选四，在实验报告中回答。 minilexer 是如何使得 int 被分析成一个关键字而非一个标识符的？ 修改 minilexer 的输入（lexer.setInput 的参数），使得 lex 报错，给出一个简短的例子。 miniparser 的算法，只有当语法满足什么条件时才能使用？ 修改 minilexer 的输入，使得 lex 不报错但 parser 报错，给出一个简短的例子。 一种暴力算法是，只做 lex，然后在 token 流里面寻找连续的 Return，Integer 和 Semicolon，找到以后取得 Integer 的常量 a，然后类似上面目标代码生成。这个暴力算法有什么问题？ 除了我们的暴力 miniparser，形式语言与自动机课中也描述了一种算法，可以用来计算语法分析树。请问它是什么算法，时间复杂度是多少？ 总结 本节引入了很多概念，请仔细消化 Lexer Token Parser 抽象语法树 语义检查 目标代码生成 Visitor 备注 1. 之所以说“流”而不是“列表”，是因为不一定 lexer 一下就把所有的 token 都拿出来，还可以按照后续阶段的需要按需返回 token。 ↩ 2. 当然，就第一个步骤来说，你直接找到 Integer 节点也可以 ↩ "},"docs/lab1/part2.html":{"url":"docs/lab1/part2.html","title":"词法语法分析工具","keywords":"","body":"实验指导 step1：词法语法分析工具 第一部分中，我们已经自己从零开始暴力实现了一个编译器，接下来我们就来改进它。 第一个方向是： 使用工具完成词法语法分析，而不是自己手写 。 当然你可以自己写 lexer 和 parser，但你就需要理解 lexer 和 parser 的算法，并且代码量更大。 请直接看手写 lexer 和 parser。 工具概述 从 minilexer/miniparser 的代码可以看出，lexer 和 parser 包含两部分： 被分析的词法/语法的描述。例如 minilexer 的那个 TokenType 列表，以及 miniparser 的 rules 字符串； lexer 和 parser 的驱动代码。例如 lex 和 parse 函数。 使用工具，我们只需要完成第一步，描述被分析的词法或者语法。 然后工具从我们的描述，自动生成 lexer 或者 parser 供你使用，十分方便。 所以这类工具被称为 lexer/parser generator，例子有：C 的 lex/yacc、往届使用的 JFlex / Jacc、mashplant 助教自己写的 lalr1。 对有兴趣的同学：除了这类工具以外，还有一类工具称为 parser combinator，多在函数式语言中使用。 最有名的如 Haskell 的 parsec、scala 的 fastparse，rust 的 nom。课程不涉及其中内容。 下面是助教写的一些工具的速成介绍，你可从中选择一个学习使用， 你也可以自己另找其他工具自学使用。 ANTLR ANTLR 是一个比较易用的 parser generator，速成文档在这里。 LALR1 TODO：如果较长，写在单独的文档里面 手写 lexer 和 parser TODO：如果较长，写在单独的文档里面 任务 如果你选择使用工具：按照你选择的工具，描述 step1 的 MiniDecaf 词法语法，并从 AST 生成汇编。 如果你不选择使用工具：实现你自己的 lexer 和 parser，并生成汇编。 "},"docs/lab1/part3.html":{"url":"docs/lab1/part3.html","title":"使用中间码","keywords":"","body":"实验指导 step1：使用中间码 我们继续改进上一步我们得到的编译器，这次要做的是： 使用中间码让编译器更模块化。 栈机器和中间表示 词法分析 语法分析 IR生成 目标代码生成 字节流 ----------> Tokens ----------> 语法树 --------> *IR* --------------> RISC-V 汇编 中间表示（也称中间代码，intermediate representation / IR）是位于语法树和汇编之间的一种程序表示。 它不像语法树一样保留了那么多源程序的结构，也不至于像汇编一样底层。 我们的实验中，使用简单的栈式机 IR，这里是它的一个详细描述。 容易看出，IR 的好处有如下几点 缩小调试范围，通过把 AST 到汇编的步骤一分为二。 通过观察 IR 是否正确生成就能知道：到底是 IR 生成这一小步有问题，还是 IR 到汇编这一小步有问题。 比起 AST 到汇编当成一整个大步骤，分成两个小步，每步代码更少，更容易调试。 更容易适配不同指令集（RISC-V, x86, MIPS, ARM...）和源语言（MiniDecaf, Decaf, C, Java...）。 不同源语言的 AST 不同，直接从 AST 生成汇编的话，为了支持 N 个源语言和 M 个目标指令集，需要写 N * M 个目标代码生成模块： 如果有了 IR，只需要写 N 个 IR 生成和 M 个汇编生成，一共 N + M 个模块： 我们使用栈式机 IR 因为它很简单，IR 生成很简单、翻译到汇编也很简单。 当然，就课程实验来说，你不一定非要显式地生成 IR，可以直接从 AST 生成汇编。 但只要按照实验指导书的思路，你一定会使用栈机器的思路思考，“眼前无 IR 心中有栈式机”。 所以指导书中，会把 IR 单独拿出来，不会直接讨论 AST 如何翻译到汇编。 从 AST 到 IR 词法分析 语法分析 *IR生成* 目标代码生成 字节流 ----------> Tokens ----------> 语法树 ---------> IR ---------------> RISC-V 汇编 显然，这一步的 输入 是 AST， 输出 是一系列 IR 1 例如前面的 int main(){return 0;} 例子，输出如 [const 0, ret] 每步我们只介绍必须的 IR，而不是一股脑全整完。 对于第一步，我们只需要两个 IR 指令：const、ret，如下表。 指令 参数 含义 IR 栈大小变化2 const 一个整数常数 把一个常数压入栈中 增加 1 ret 返回栈顶元素 弹出栈顶元素，将其作为返回值返回当前函数 减少 1 并且我们有如下的假设： 考虑源代码中某个表达式被翻译成了一系列 IR 指令，那么从任何初始状态出发执行这些 IR 指令， 完成后 IR 栈大小增加 1，栈顶就是表达式的值。 执行任何 n 元操作之前，栈顶的 n 个元素就是操作数。 n 元操作将这 n 个元素弹出，进行操作，再把结果压回栈中。 由此，step1 中 AST 翻译到 IR 就很简单了。只需要 Visitor 遍历 AST，然后 遇到 Integer(X)：生成一条 const X，栈大小加 1。 遇到 Return expr ;：先生成 expr 对应的 IR，栈大小加 1；然后生成一条 ret，栈大小和原来相同。 IR 翻译到汇编 词法分析 语法分析 IR生成 *目标代码生成* 字节流 ----------> Tokens ----------> 语法树 ---------> IR ---------------> RISC-V 汇编 栈机器 IR 翻译到汇编非常简单，如下表，多条汇编指令用分号隔开： IR 汇编 push X addi sp, sp, -4 ; li t1, t1, X ; sw t1, 0(sp) ret lw a0, 0(sp) ; addi sp, sp, 4 ; jr ra 简要解释：li t1 X 表示加载立即数 X 到寄存器 t1；RISC-V 和 x86 一样栈顶比栈底的地址低，所以压栈 4 字节是栈指针 sp 减 4。 （RISC-V 的栈顶指针是 sp，类似 MIPS 的 $sp 和 x86 的 %esp 或 %rsp。） a0 存放返回值，ra 存了调用者地址，jr ra 就是子函数返回。 t1 没有什么特殊的含义，你可以换成 t0 / t2 / s1 等。 但不要用 s0，因为它保存了栈帧基地址（同 %ebp 和 $fp），后面要用到。 IR 栈的每个元素都是 32 位整数，所以 push 使得 IR 栈大小加 1 在我们这里就体现为 sp 减 4。 完成后，你对于 int main(){return 0;} 应该生成如下汇编 .text .globl main main: addi sp, sp, -4 li t1, 233 sw t1, 0(sp) lw a0, 0(sp) addi sp, sp, 4 jr ra 任务 （可选，推荐）改进你上一步的代码，先生成 IR，再从 IR 生成汇编，通过测例。 （和 1. 二选一）改进你上一步的代码，不显示生成 IR，但使用栈机器的思路生成汇编，通过测例。 思考题 ANTLR 栈机器 总结 备注 1. 实际上 const 和 ret 是 IR 的 指令。我们为了简便，通常直接用 IR 代指 IR 指令。 ↩ 2. 注意区分 IR 栈和汇编中的栈。IR 的栈中包含的元素是整数，IR 栈的大小指栈中有多少个整数。对于 IR 的栈不存在“字节”这一概念。 ↩ "},"docs/lab1/antlr.html":{"url":"docs/lab1/antlr.html","title":"ANTLR 使用","keywords":"","body":"ANTLR 使用——以表达式语法为例 使用 ANTLR 工具，我们只需要写出词法和语法分析的 规范（specification）， 然后它会帮我们生成 lexer 和 parser 乃至 visitor，非常方便。 我们用一个简单的表达式语法 1 来介绍 ANTLR，表达式由一系列整数通过加减乘除以及括号构成，例如 (1+3)*4-3-3。 对于 ANTLR，词法和语法分析的规范都写在 .g4 2 文件中，例如我们的表达式的规范是文法: ExprLex.g4和语法: Expr.g4。 无论是词法规范还是语法规范，它们的规范文件结构是一样的，如下。 规范文件中，// 表示注释，规范是大小写敏感的，字符串常量用单引号括起。 开头声明 规范名，需要和文件名一致： // [ExprLex.g4] 词法规范，用 lexer grammar 标识，行尾有分号。 lexer grammar ExprLex; // [Expr.g4] 语法规范，用 grammar 标识，行尾有分号。 grammar Expr; 然后可能有一些 规范自身的设置，见后面 “语法规范” 然后是 一系列规则，规则类似上下文无关语法的产生式。 每条规则包含左右两边，用冒号隔开， 左边 是一个符号，可以由 右边 规约而来。 符号分为 终结符 和 非终结符 ，终结符用大写字母打头，非终结符用小写字母。 类似产生式，如果多条规则的左边相同，它们可以合并写在一起，它们的右手边用竖线隔开。 // [ExprLex.g4] 词法规则，规则末尾有分号。 Integer: [0-9]+; // [Expr.g4] 语法规则，规则末尾有分号 atom : '(' expr ')' // 一个括号括起来的表达式，它可以规约到 atom | Integer // 整数 token 可以规约到 atom ; 词法规范 词法规范描述了 lexer 应该怎么生成，显然词法规范中规则的左边只能是终结符。 除了上面所说的，词法规范还有一点是：规则的右手边是一个正则表达式。 详细用法在这里，一些常见用法如下： // 1. 为了匹配字符串常量，用单引号把它括起来 Lparen: '('; // 2. [0-9] 匹配 (char)'0' 到 (char)'9' 之间任何一个字符，类似其他 regex 的 \\d 或者 [[:digit:]] // 3. 加号 + 表示它前面的片段可以匹配一次或多次，类似有 * 的零次或多次，? 的零次或一次。 // 它们都是贪婪的，会匹配尽量多的次数。和其他 regex 一样，片段可以用 ( ) 分组。 Integer: [0-9]+; // 4. fragment 表示 WhitespaceChar 本身不是一个符号，它只是一个 regex 的片段，lexer 不会产生它的 token。 // 它和 minilexer 中的 whitespaceChar 是一样的。 // 5. [ \\t\\n\\r] 匹配一个空格 (ascii 码 0x20)，或者一个制表符 (0x9)，或者一个换行符 (0xa) 或者一个回车 (0xd) fragment WhitespaceChar: [ \\t\\n\\r]; // 6. Whitespace 匹配输入中的空白。类似 minilexer，\"-> skip\" 表示忽略此终结符，也就是匹配以后不产生对应的 token。 Whitespace: WhitespaceChar+ -> skip; 语法规范 语法规范描述了 parser 应该怎么生成。除了上面说的，还需注意： parser 依赖于 lexer，所以语法规范中需要 导入词法规范 // 导入词法规范 import ExprLex; 其实 ANTLR 不要求你分开 lexer 和 parser，你可以直接把 import 语句换成 ExprLex 里面的所有规则， 效果是一样的。 但分开 lexer 和 parser 更干净，并且也方便 lexer 复用。 各种语言虽然语法差别很大，词法（空白、整数、标识符、标点符号等）却没太大差别。 parser 规则的右手边除了符号以外，还可以有 字符串常量。 如果它能被规约到词法规范里某个符号，那它就等价于那个符号； 否则 ANTLR 内部会生成一个临时终结符 T__xxx，它的规则的右边是那个字符串常量。 mulOp : '*' | '/' ; // 等价于 mulOp : Mul | Div ; 你可以手动给 规则命名。 在生成的 AST 里，atom 对应的结点会被分为两类：atomParen 和 atomInteger， 它们拥有的字段不同，也对应不同的 visit 函数。 atom : '(' expr ')' # atomParen | Integer # atomInteger ; 规则其实是用 EBNF (extended Barkus-Naur form) 记号书写的，EBNF 也是描述上下文无关语法的一种方式。 相对普通的上下文无关语法记号，EBNF 允许你在规则内部使用 | 描述选择、* 或 ? 或 + 描述重复，(和) 分组 3。 例如下面的用法： add // 1. 使用括号分组，分组内部使用 | 描述选择 // 2. 和 EBNF 无关，但 op 是给这个符号的命名，然后 add 的 AST 结点会有一个 op 字段。 : add op=(Add|Sub) mul | mul ; mul // 3. 使用 * 描述零次或多次的重复。+ 和 ? 类似。 : atom (mul atom)* ; 关于 EBNF，再举一个例子：描述零个或多个用逗号隔开的 expr 列表，下面两种写法是等价的，但 EBNF 记号更简短。 // 传统写法 exprList : # emptyExprList | exprList2 # nonemptyExprList ; exprList2 : expr | expr ',' exprList2 ; // EBNF 写法 exprList : (expr (',' expr)*)? ; 运行 ANTLR 安装 ANTLR，设置 CLASSPATH 环境变量，配置 antlr4 和 grun 的 alias 后，运行以下命令 4： $ antlr4 Expr.g4 # 会自动拉取 import 的 ExprLex.g4 $ ls ExprLexer.java ExprParser.java # 默认生成 Java 的 lexer 和 parser，其他文件不用管 ExprLexer.java ExprParser.java $ javac *.java $ echo \"(1+3)*4-3-3\" > input # 输入文件内容是 (1+3)*4-3-3 $ grun Expr expr -gui input # 输出如下图 你可以尝试把最后一步的 -gui 换成 -tokens、-tree 看看。 接下来，我们给出示例代码，叙述如何使用生成的 lexer 和 parser。 Main.java 是 Java 的示例代码。做完上面步骤后，运行 Main： $ java Main main.py 是 Python 的示例代码。为了运行它，除了安装 ANTLR 你还需要安装 Python 的 ANTLR API，见这里。运行方法如下 $ antlr4 Expr.g4 -Dlanguage=Python3 $ ls ExprParser.py ExprLexer.py # 生成了 Python 的 lexer 和 parser ExprLexer.py ExprParser.py $ python3 main.py (expr (add (add (add (mul (atom ( (expr (add (add (mul (atom 1))) + (mul (atom 3)))) )) (mulOp *) (atom 4))) - (mul (atom 3))) - (mul (atom 3)))) Visitor 的使用 ANTLR 默认生成 listener，它允许你在遍历 AST 过程进入结点和离开结点的时候运行一些代码，但我们不用 listener，我们使用 visitor。 首先用参数 -visitor 告诉 ANTLR 生成 visitor 代码。 $ antlr4 Expr.g4 -visitor visitor 代码在 ExprVisitor.java 和 ExprBaseVisitor.java 中。 前者定义接口，后者是默认实现：只遍历、不做其他事。 public class ExprBaseVisitor extends AbstractParseTreeVisitor implements ExprVisitor { @Override public T visitExpr(ExprParser.ExprContext ctx) { return visitChildren(ctx); } // ... } 从上可以看出，ANTLR 的 visitor 和我们的基本一致： visit 函数返回值的类型是 T 他所谓 context 就是 AST 的结点，每个 context 也有一个 accept 函数接受 visitor 但他的 visitor 还自带一个方法 visitChildren：遍历所有子结点。返回最后一个子结点的返回值。 ANTLR 生成的 python visitor 也差不多 $ antlr4 Expr.g4 -visitor -Dlanguage=Python3 visitor 在 ExprVisitor.py 里。 # ExprVisitor.py class ExprVisitor(ParseTreeVisitor): def visitExpr(self, ctx:ExprParser.ExprContext): return self.visitChildren(ctx) # ... MainEval.java 和 maineval.py 通过表达式求值展现了 visitor 的用法，如上编译后如下运行即可。 输出的 10 就等于 (1+3)*4-3-3。 $ python3 mainvisitor.py 常见问题 javac 报错一堆 cannot find symbol 没有设置 CLASSPATH grun 报错 Can't load Expr as lexer or parser 你 antlr4 以后没有编译 java 文件 我的输入是 1+2 ((( 它竟然不报错 ANTLR 不强制消耗整个输入，所以 parser 做完 1+2 就停了。 可以把 expr: add; 改成 expr: add EOF; antlr4 报错 error(31): ANTLR cannot generate python3 code as of version 4.8 -Dlanguage=Python3 的 P 要大写 备注 1. step1 的 MiniDecaf 语法太简单，不能体现很多 ANTLR 的特性。 ↩ 2. g 是 grammar，4 是 ANTLR 的版本号 4。 ↩ 3. EBNF 本身又有很多记号，有的使用 { ... } 表示重复。我们描述的是 ANTLR 的 EBNF 记号。 ↩ 4. 命令从 https://www.antlr.org/ 中 Samples 的内容修改而来 ↩ "},"docs/lab1/visitor.html":{"url":"docs/lab1/visitor.html","title":"Visitor 模式","keywords":"","body":"Visitor 模式速成 编译器的构造中会使用到很多设计模式，Visitor 模式就是常见的一种。 基础的设计模式都在 OOP 课程中覆盖，这里重提一下 Visitor 模式，顺带介绍一些参考代码用到的 python 技巧。 我们知道，编译器里有很多的树状结构。 最典型的就是，源程序通过上下文无关文法解析后，得到的语法分析树。 Visitor 模式的目的，就是遍历这些树状结构，本质就是一个 DFS 遍历。 下面通过一个例子说明 Visitor 模式。 表达式语法、语法树定义 我们有一个很简单的表达式文法，终结符包括整数和加减乘除模操作符，起始符号是 expr，大致如下 expr -> int | binary int -> Integer binary -> expr '+' expr | expr '-' expr | expr '*' expr | expr '/' expr | expr '%' expr 这个文法有二义性，同样的字符串可能有多个语法分析树。 不过解析字符串、生成语法分析树不是 Visitor 模式的工作。 Visitor 模式只考虑某个确定的语法分析树。 如下面是 20-13*3 的一颗语法分析树 我们在代码里这样定义这个语法分析树（python 3.6）： class Node: pass class IntNode(Node): def __init__(self, v:int): # 类型标注是给人看的，python 不检查 self.v = v def __str__(self): return f\"({self.v})\" # f-string 特性 class BinopNode(Node): _legalOps = { *\"+-*/%\" } # 使用 unpacking operator，等价于 set('+', '-', '*', '/', '%') def __init__(self, op:str, lc:Node, rc:Node): assert op in BinopNode._legalOps self.op, self.lc, self.rc = op, lc, rc def __str__(self): return f\"({self.lc} {self.op} {self.rc})\" # 我们通过某种手段，得到了这么一个语法分析树 expr1 = BinopNode('*', BinopNode('-', IntNode(20), IntNode(13)), IntNode(3)) print(expr1) # (((20) - (13)) * (3)) 我们忽略了 Expr，不过显然这无伤大雅。 表达式求值 显然，每个语法分析树都对应一个（加好括号）的表达式，比如上面的树就对应 (20-13)*3。 那么我们考虑一个问题：如何对这个表达式求值？ 当然，我们可以让 python 帮我们做 print(eval(str(expr1), {}, {}))， 不过我们下面会用 Visitor 模式实现表达式求值。 写 Visitor 之前，我们看自己实现表达式求值的最简单的方法，一个递归遍历： def dfs(node:Node): if isinstance(node, IntNode): return node.v if isinstance(node, BinopNode): lhs = dfs(node.lc) rhs = dfs(node.rc) if node.op == \"+\": return lhs + rhs if node.op == \"-\": return lhs - rhs if node.op == \"*\": return lhs * rhs if node.op == \"/\": return lhs / rhs if node.op == \"%\": return lhs % rhs print(dfs(expr1)) # 21 dfs 函数接受一个结点，然后对这个结点代表的子树进行求值，返回求值结果。 容易看出，dfs 函数根据被遍历的结点类型不同，执行不同的求值逻辑。 那么我们把这些求值逻辑封装到一个类里面，就得到了一个最简单的 Visitor。 class EvaluationVisitor: def visit(self, node:Node): if isinstance(node, IntNode): return self.visitIntNode(node) if isinstance(node, BinopNode): return self.visitBinopNode(node) def visitIntNode(self, node:IntNode): return node.v def visitBinopNode(self, node:BinopNode): # 不确定子结点的类型，所以只能调用 visit 而非 visitIntNode 或者 visitBinopNode lhs = self.visit(node.lc) rhs = self.visit(node.rc) if node.op == \"+\": return lhs + rhs if node.op == \"-\": return lhs - rhs if node.op == \"*\": return lhs * rhs if node.op == \"/\": return lhs / rhs if node.op == \"%\": return lhs % rhs print(EvaluationVisitor().visit(expr1)) # 21 上面就是 Visitor 的核心思想，实际使用中我们一般会有两点改进 不使用 isinstance 来判断结点类型，而是调用结点自身的一个 accept 函数 把几个 visitXXX 函数抽象到一个接口里，各种具体的 Visitor 来实现这个接口 改进后的 Visitor 如下。 class Node: def accept(self, visitor): pass class IntNode(Node): # ... 同上 def accept(self, visitor): return visitor.visitIntNode(self) class BinopNode(Node): # ... 同上 def accept(self, visitor): return visitor.visitBinopNode(self) class Visitor: # 默认行为是遍历一遍，啥也不做，这样比较方便 def visitIntNode(self, node:IntNode): pass def visitBinopNode(self, node:BinopNode): node.lc.accept(self) node.rc.accept(self) class EvaluationVisitor(Visitor): def visitIntNode(self, node:IntNode): # ... 同上 def visitBinopNode(self, node:BinopNode): lhs = node.lc.accept(self) rhs = node.rc.accept(self) # ... 同上 总结 从上面可以看到，Visitor 模式的要素有 被访问的对象。例如上面的 Node。 Visitor 封装的 visitXXX，表示对上述对象实施的操作。例如 EvaluationVisitor。 每种被访问的对象在自己的定义中都有一个 accept 函数，并且在 Visitor 里面也对应一个 visitXXX 函数。 有状态的 Visitor subexpr = BinopNode('-', IntNode(20), IntNode(13)) expr1 = BinopNode('*', subexpr, IntNode(3)) 显然，表达式求值的过程中，所有子表达式也都会被求值。 如上，求值 expr1 的过程中，subexpr 也也会被求值。 我们想把子表达式的值记录下来，以后直接使用，就不需要对子表达式重新求值了。 为了实现这点，还是使用上面的 EvaluationVisitor，但我们用一个字典 Node -> int 记录求值结果，并且把字典作为 Visitor 的状态。 class EvaluationVisitor2(Visitor): def __init__(self): self.value = {} # Node -> int 每次 EvaluationVisitor2.visitXXX(self, node) 返回的时候，我们都记录一下 self.value[node] = value，其中 value 是返回值。 我们用一个函数修饰器来完成记录的动作，如下 class EvaluationVisitor2(Visitor): def __init__(self): self.value = {} # Node -> int def SaveValue(visit): # decorator def decoratedVisit(self, node): value = visit(self, node) self.value[node] = value return value return decoratedVisit @SaveValue def visitIntNode(self, node:IntNode): return node.v @SaveValue def visitBinopNode(self, node:BinopNode): lhs = node.lc.accept(self) rhs = node.rc.accept(self) if node.op == \"+\": return lhs + rhs if node.op == \"-\": return lhs - rhs if node.op == \"*\": return lhs * rhs if node.op == \"/\": return lhs / rhs if node.op == \"%\": return lhs % rhs subexpr = BinopNode('-', IntNode(20), IntNode(13)) expr1 = BinopNode('*', subexpr, IntNode(3)) visitor = EvaluationVisitor2() expr1.accept(visitor) print(visitor.value[subexpr]) # 7 print(visitor.value[expr1]) # 21 "},"docs/lab1/ir.html":{"url":"docs/lab1/ir.html","title":"IR 简明介绍","keywords":"","body":"中间代码 中间代码(也称中间表示，Intermediate Representation, IR)是表示程序结构的一种方式，在后续的实验中，我们会先由AST生成IR，再由IR生成汇编代码。尽管直接由AST生成汇编代码在我们的实验中也是完全可行的，但是保留这个中间步骤更加符合真实的编译器的工作流程。一般真实的编译器都有IR这个中间步骤，这是因为IR一般比AST更加接近汇编，同时仍然保存了一些程序中的高级信息，更加适合进行各种优化。 IR有很多种类，包括三地址码(Three Address Code, TAC)，静态单赋值形式(Static Single Assignment Form, SSA)，基于栈的IR，等等。如果你感兴趣的话可以自行查阅了解，这里不做要求。 我们的教程选择使用基于栈的IR。这种IR的最大特点是中间代码生成和汇编代码生成(不追求性能的话)非常容易编写，但是一般实际的编译器都不会使用它，因为它并不适合进行优化1，这样其实也就失去了IR存在的根本意义之一了。尽管如此，我们这个教学用的编译器还是选择使用基于栈的IR，主要目的是希望体现IR这个结构在实际的编译器中的地位，尽量让大家体会感受编译器的工作流程，只是限于课程的工作量的限制还是没法和实际的编译器做到真正的一致。 基于栈的IR顾名思义需要维护一个运算栈，它最主要的特点在于它的运算指令，例如加法和减法指令这些，是没有显式的操作数的。例如在编程语言中常常会写a = b + c，这里的b和c就是加法操作的操作数，而基于栈的IR中则不存在这样的结构，相当于只用一个加号来表示加法，不给出这个加法的操作数。这样的的运算指令的语义都是从这个运算栈的顶部弹出操作数，进行运算后再把结果压回栈中。 例子：一加到一百 在之后的每个step中，我们都会介绍(我们推荐的)加入IR的新指令。尽管如此，这里为了给大家留下一些直观的印象，还是先定义一套简单的基于栈的IR，并且用它表示一个简单的例子：计算一加到一百的和。 定义如下指令： PUSH x: 往运算栈中压入常数x LOAD var: 将变量var的值读出，压入栈中 STORE var: 从栈顶弹出一个值，写入变量var LABEL l: 定义一个名为l的标号 BZ l: 从栈顶弹出一个值，如果该值等于0，则跳转到标号l执行，否则继续执行下一条指令 B l: 无条件跳转到标号l执行 CMP_LE/ADD: 两条二元运算指令，从栈上依次弹出两个值，分别作为右操作数和左操作数，执行整数二元运算/+，将结果压入栈中 有几点可能是比较容易引起疑惑的，这里简单解释一下： 很多指令(其实是除了CMP_LE/ADD之外的所有指令)都有额外的参数，看起来不符合上面说的\"运算指令没有显式的操作数\"的特点。可以理解成\"运算指令\"指的就是CMP_LE/ADD这样的狭义地进行计算操作的指令，其他的都不属于运算指令。 上面提到了\"变量\"的概念，变量是保存在哪里的呢？假如要把这个IR最终翻译成汇编，运算栈显然会用栈来实现，而局部变量其实也只能保存在栈上，虽然保存在很接近的物理区域，但是它们逻辑上并不是运算栈的一部分，对局部变量的写入不应该影响到运算栈，在运算栈上进行的弹栈/压栈操作也不应该影响到局部变量。 上面提到的var，l这样的名字，实际实现的时候基本都是用整数来表示，而下面的程序中为了清晰起见，还是用人可读的名字来表示。 下面我们用这个IR来表示如下的C程序： int sum = 0; int i = 1; while (i 转化的结果如下(#后的是注释)： PUSH 0 STORE sum # int sum = 0; PUSH 1 STORE i # int i = 0; LABEL loop LOAD i PUSH 100 CMP_LE # 计算i 我们有一个 ir.py（代码）能运行上面程序，结果的确是 1+2+...+100=5050. $ python3 ir.py 5050 标有*和**的两条指令在i = 50时执行前后的状态变化如下： 这里局部变量sum和i的保存位置就和上面描述的差不多，与运算栈保存在接近的物理区域，但是二者互不干扰。 执行ADD前，运算栈上恰好有两个元素，也就是前两条指令依次压入栈中的sum和i的值，当前栈顶的值是i的值50。执行ADD时，将这两个值依次弹出，栈顶的值作为右操作数，栈顶下的一个值作为左操作数，执行加法得到1226，再把1226压回栈中，执行完后运算栈上恰好有一个元素1226。 执行STORE sum时，将栈顶的1226弹出，存入sum所在的位置，执行完后sum的值被更新为1226，运算栈为空。 备注 1. 类似Java Bytecode这样的，虽然也属于基于栈的IR，但是实际的Java虚拟机中都会先把它转化成其它容易优化的形式，所以它的意义仅仅是便于生成和传输，几乎不会用于优化。这也启示我们，尽管我们选择了不容易优化的基于栈的IR，但未来还是有拓展的空间，可以把它转化成其他形式再进行优化。 ↩ "},"docs/lab1/spec.html":{"url":"docs/lab1/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step1 语法规范 我们采用 EBNF (extended Barkus-Naur form) 记号书写语法规范，采用类似 ANTLR 的记号： 小写字母打头的是非终结符（如 program），大写字母打头的是终结符（如 Identifier），可以用字符串字面量表示终结符（如 'int'） 后面会用到：( 和 ) 表示分组，| 表示选择，* 零或多次，+ 一或多次，? 零或一次 EBNF 也有很多写法，另一种是用尖括号表示非终结符 ::= 等。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer step1 语义规范 1.1. MiniDecaf 的 int 类型具体指 32 位有符号整数类型，范围 [-2^31, 2^31-1]，补码表示。 1.2. 编译器应当只接受 [0, 2^31-1] 范围内的整数, 我们未来会支持负数。 如果整数超过此范围，编译器应当报错。 "},"docs/lab2/intro.html":{"url":"docs/lab2/intro.html","title":"任务概述","keywords":"","body":"实验指导 step2：一元运算符 step2 中，我们要给整数常量增加一元运算：取负 -、按位取反 ~ 以及逻辑非 !。 语法上，我们需要修改 expression 的定义，从 expression : Integer 变成： expression : unary unary : Integer | ('-'|'!'|'~') unary 三个操作的语义和 C 以及常识相同，例如 ~0 == -1，!!2 == 1。 稍微一提，关于按位取反，我们使用补码存储 int；关于逻辑非，只有 0 表示逻辑假，其他的 int 都是逻辑真。 "},"docs/lab2/guide.html":{"url":"docs/lab2/guide.html","title":"实验指导","keywords":"","body":"step2 实验指导 我们按照上一节划分的编译器阶段，分阶段给出 step2 实验指导。 词法语法分析 如果你使用工具完成词法语法分析，修改你的规范以满足要求，剩下的交给工具即可。 语法规范已经给出，词法规范的变化也很简单，新增三个 token：-、~ 和 !。 你的规范和我们的要求等价、能通过测试即可，不用完全一样。 语义检查无需修改。 如果你是手写分析，TODO IR 生成 显然，我们要引入一类 IR 表示一元操作。 一元操作 IR 的含义是：弹出栈顶，对弹出的值做某个一元操作，再把操作的结果值压入栈顶。 换言之，就是直接对栈顶做某个操作。 指令 参数 含义 IR 栈大小变化 neg 无参数 栈顶取负 不变 not 同上 栈顶按位取反 不变 lnot 同上 栈顶取逻辑非 不变 和 step1 一样，这一节所讲的领悟意思即可。 你不用照着实现。 例如你可以把三条指令变成一条 Unary(op)，其中 op 是 \"-\"、\"~\" 或 \"!\"。 你甚至也不必显式转成 IR。 和 step1 一样，采用 Visitor 模式遍历 AST 来生成 IR。除了 step1 的要求，step2 还要求你遍历 AST 时， 遇到一元表达式的时候，先生成子表达式的 IR，然后再根据操作类型生成一个 neg 或 not 或 lnot 所以，~!--3 会翻译成 push 3 ; neg ; neg ; lnot ; not 五条 IR 指令。 汇编生成 很简单，如下表。 IR 汇编 neg lw t1, 0(sp) ; neg t1, t1 ; sw t1, 0(sp) not …… lnot …… 要知道每个操作生成什么样的汇编，可以参考 gcc 的输出。 例如我们想知道取负的汇编，那我们用 gcc 编译 int foo(int x) { return -x; }， 结果如下（记得加 -O3），我们就知道取负是 neg 目标寄存器, 操作数寄存器。 foo: neg a0,a0 ret 仿照上面，自己确定 not 和 lnot 的汇编。 任务 改进你的编译器，支持本节引入的新特性，通过相关测试。 实验报告中回答思考题。 总结 本节内容不多，也很简单。 "},"docs/lab2/spec.html":{"url":"docs/lab2/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step2 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : unary unary : Integer | ('-'|'!'|'~') unary step2 语义规范 2.1. MiniDecaf 中，负数字面量不被整体作为一个 token。它被看成是一个取负符号、后面是它的绝对值。 所以我们无法用字面量表示 -2147483648，但可以写成 -2147483647-1（待我们加上四则运算后）。 2.2. 运算越界是未定义行为。例如 -(-2147483647-1) 是未定义行为。 2.3. 除非特别声明，子表达式求值顺序是不确定的。 例如：执行 int a=0; (a=1)+(a=a+1); 之后 a 的值是不确定的。 "},"docs/lab3/intro.html":{"url":"docs/lab3/intro.html","title":"任务概述","keywords":"","body":"实验指导 step3：加减乘除模 step3 我们要增加的是：加 +、减 -、乘 *、整除 /、模 % 以及括号 ( )。 语法上我们继续修改 expression，变成 expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1+2*(4/2+1) == 7。 "},"docs/lab3/guide.html":{"url":"docs/lab3/guide.html","title":"实验指导","keywords":"","body":"step3 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 语义检查无需修改。 如果你是手写分析，TODO IR 生成 我们同样引入一类 IR 表示二元操作。 执行二元操作的 IR 时，两个操作数需要位于栈顶，然后它们被弹出、进行相应操作，再把结果压入栈顶。 不妨规定二元操作的右操作数在栈顶，左操作数在右操作数下面，那么有如下例子： 3-10 翻译成 push 3 ; push 10 ; sub 三条指令。 +------------+ 栈顶 | 10 | +------------+ ----------> +------------+ 栈顶 | 3 | 执行 sub | -7 | +------------+ +------------+ | ...... | | ...... | 指令 参数 含义 IR 栈大小变化 add 无参数 弹出栈顶两个元素，压入它们的和 减少 1 sub 无参数 弹出栈顶两个元素，压入它们的差，顺序如上 减少 1 mul、div、rem 无参数 ……乘除模 减少 1 类比 step2，生成 IR 时 Visitor 遍历 AST 遇到二元操作，需要（注意 1. 和 2. 的顺序） 首先生成左操作数的 IR（左操作数入栈，栈顶是左操作数） 然后生成右操作数的 IR（右操作数入栈，栈顶是右操作数) 根据操作不同生成对应的二元 IR 上面的 3 步执行完后，栈大小比执行第 1. 步以前增加 1，栈顶就是二元操作的结果。 这符合我们在 step1 中的假设： 考虑源代码中某个表达式被翻译成了一系列 IR 指令，那么从任何初始状态出发执行这些 IR 指令， 完成后 IR 栈大小增加 1，栈顶就是表达式的值。 汇编生成 仿照 step2 所说，用 gcc 自己确定 sub/mul/div/rem 的汇编。 IR 汇编 add lw t1, 4(sp) ; lw t2, 0(sp) ; add t1, t1, t2 ; addi sp, sp, 4 ; sw t1, 0(sp) sub,mul,div,rem …… 任务 改进你的编译器，支持本节引入的新特性，通过相关测试。 实验报告中回答思考题。 总结 本节重点是执行过程中栈的变化，以及上面提到的 step1 的假设，参见上面 IR 生成一节。 "},"docs/lab3/spec.html":{"url":"docs/lab3/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step3 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step3 语义规范 3.1. 除以零、模零都是未定义行为。 "},"docs/lab4/intro.html":{"url":"docs/lab4/intro.html","title":"任务概述","keywords":"","body":"实验指导 step4：比较和逻辑表达式 step4 我们要增加的是： 比较大小和相等的二元操作：、、>=, >, ==, != equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive 逻辑与 &&、逻辑或 || expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1=2 是逻辑真（int 为 1）。 但特别注意，C 中逻辑运算符 || 和 && 有短路现象，我们不要求。 "},"docs/lab4/guide.html":{"url":"docs/lab4/guide.html","title":"实验指导","keywords":"","body":"step4 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 语义检查无需修改。 如果你是手写分析，TODO IR 生成 沿用 step3 加入的二元操作 IR（以及左右操作数的位置），新的 IR 如下。 指令 参数 含义 IR 栈大小变化 eq 无参数 ==（弹出栈顶两个元素，如果相等压入 1，否则压入 0） 减少 1 ne 无参数 ……!= 减少 1 le 无参数 …… 减少 1 ge 无参数 ……>= 减少 1 lt 无参数 …… 减少 1 gt 无参数 ……> 减少 1 land 无参数 ……&& 减少 1 lor 无参数 弹出栈顶两个元素，将其逻辑或压入栈 减少 1 当然，IR 设计很灵活。参见思考题 3。 汇编生成 对于比较大小和相等的操作，参照 gcc 结果，自行完成汇编生成。 逻辑表达式会麻烦一点，因为 gcc 可能生成跳转，所以下面给出 land 和 lor 对应的汇编。 表格中，我们省略了汇编的前缀 lw t1, 4(sp) ; lw t2, 0(sp) 和后缀 addi sp, sp, 4 ; sw t1, 0(sp)。 注意 RISC-V 汇编中的 and 和 or 都是位运算指令，不是逻辑运算指令。 IR 汇编 land or t1,t1,t2 ; snez t1,t1 lor snez t1,t1 ; snez t2,t2 ; and t1,t1,t2 任务 改进你的编译器，支持本节引入的新特性，通过相关测试。 实验报告中回答思考题。 总结 step4 和 step3 差别不大。 "},"docs/lab4/spec.html":{"url":"docs/lab4/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step4 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step4 语义规范 4.1. 如果 || 和 && 的子表达式有副作用，那么这就是一个未定义行为。 换言之，不对逻辑表达式的短路求值做要求。 4.2. 比较大小是有符号数的比较大小，因此 0xFFFFFFFF == -1 。 "},"docs/lab5/part0-intro.html":{"url":"docs/lab5/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab5/part1-parse.html":{"url":"docs/lab5/part1-parse.html","title":"词法语法分析","keywords":"","body":"词法语法解析 支持多条语句 从本步骤开始，函数中可能具有多条语句，而不再只有一个返回语句。相关符号的定义变更为： ::= \"int\" \"main\" \"(\" \")\" \"{\" { } \"}\" ::= \"return\" \";\" | \";\" 文法中的 { } 记号表示 可重复 0 至任意多次。在语法解析器的实际实现中，也可将上述文法写作： ::= \"int\" \"main\" \"(\" \")\" \"{\" \"}\" ::= /* empty */ | 如果你选择自己亲自实现一个语法解析器，建议使用后一种文法以简化实现。如果你使用了 antlr 等解析器生成工具，可以尝试直接编写前一种文法，但并不一定比后一种文法更方便。请根据实际情况做出选择。 标识符 在之前的步骤中，唯一的标识符——主函数名 main 是固定的。为了简洁起见，我们将 main 视为一个关键字，硬编码在词法和语法解析器中。但从本步骤开始，局部变量的名称将是不定的，故需要引入一个专门表示标识符的标记 Identifier，定义如下： Identifier [a-zA-Z_][a-zA-Z0-9_]* 而函数符号的定义则进一步变更为： ::= \"int\" Identifier \"(\" \")\" \"{\" { } \"}\" 局部变量的定义 语句符号的定义做如下进一步修改，将支持局部变量的定义和初始化视作一种语句： ::= \"return\" \";\" | \";\" | \"int\" Identifier [ \"=\" ] \";\" // 其中 [ = ] 表示初始化表达式是可选的。根据你实现解析器的方式，也可以将上述文法改写成： ::= \"return\" \";\" | \";\" | \"int\" Identifier \";\" | \"int\" Identifier \"=\" \";\" 解析器应生成相应的 AST 结点： statement = Return(exp) | Declare(string, exp option) // 其中 string 表示变量名，而 exp 是一个可选参数，表示变量的初始化表达式。 局部变量的访问和赋值 表达式符号做如下修改： ::= Identifier \"=\" | // ::= { \"||\" } ::= { \"&&\" } ::= { (\"!=\" | \"==\") } ::= { (\"\" | \"=\") } ::= { (\"+\" | \"-\") } ::= { (\"*\" | \"/\") } ::= \"(\" \")\" | | Integer | Identifier // ::= \"!\" | \"~\" | \"-\" 当 是一个 Identifier 时，表示访问一个变量。当 是 Identifier \"=\" 时，表示对变量赋值。 最后，解析器应生成相应的 AST 结点： exp = Assign(string, exp) // 其中 string 表示变量名。 "},"docs/lab5/part1-1-task.html":{"url":"docs/lab5/part1-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新你的parse函数，使其可以为所有有效的step5测试用例建立正确的AST。 "},"docs/lab5/part4-codegen.html":{"url":"docs/lab5/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 为了能够随时对就变量进行修改和引用，我们需要把局部变量保存在某个能够随时访问的地方，并记住他们的确切位置。简单起见，我们会把它们保存在栈上。 如何在编译时知道一个变量的位置呢？绝对的内存地址要到运行时才能确定，结合栈帧的知识，编译时我们可以通过fp以及固定的偏移来获取特定变量。 建立栈帧 当一个函数(我们称它为f)返回时，它的调用者需要能够接上它离开的地方。这意味着它的栈帧，以及sp和fp中的值，都需要和f被调用之前完全一样。被调用时，f需要做的第一件事就是为自己建立一个新的栈帧，使用下面的指令(不妨自己用 gcc 编译一个稍复杂的程序，看看结果)。 addi sp, sp, -framesize #建立栈帧 sw ra, framesize-4(sp) #储存返回地址（已经储存在 ra 中，为什么再次储存？） sw fp, framesize-8(sp) #储存 fp addi fp, sp, framesize #更新 fp 这些指令称为函数前序（function prologue）。目前, framesize = 变量数量 * 4 + 8（为什么？），注意，我们所有的变量长度都为4。 在f返回之前，它立即执行函数前序来删除这个栈帧，让一切都和函数前序执行之前一样。 lw fp, framesize-8(sp) #恢复 fp lw ra, framesize-4(sp) #恢复 ra addi sp, sp, framesize #恢复 sp ret 这被称为函数收尾（function epilogue）。到目前为止，我们可以不需要函数前序（function prologue）或函数收尾（function epilogue），但添加它们将减少后续面对跳转和函数时的困难。 有了这些准备： 我们可以安全地将局部变量推送到栈上，而不改变调用者的栈帧。 可以将变量位置保存为fp的偏移量。我们知道fp到sp上面没有任何东西（因为我们在函数前序中设置了一个空的堆栈框架），而且我们知道fp在函数收尾之前不会改变。 我们应该在函数定义的开始处生成函数前序，就在函数的标签之后，并在函数末尾生成函数收尾。 需要注意的是，我们需要改写之前我们的 RET 指令，它应当跳到函数收尾而不是直接 ret，考虑到目前我们没有分支指令而且只有一个函数，不改写暂时不会产生问题。 这样，我们对于变量的映射可以通过变量相对于 fp 的偏移来建立。现在让我们看看如何处理变量的声明、赋值和引用。 变量声明 碰到变量声明时，需将变量保存到栈中并设定它的偏移量。事实上，我们在函数前序中留下了变量的位置（注意栈帧的大小），也就隐式的“保存”了变量。首先我们需要一个数据结构来维护变量的信息，如：名称、类型（lab11）、声明位置、初始化语句等。至于偏移，你可以把偏移直接作为变量的属性，也可以建立一个变量到其偏移的映射，关键的问题是偏移量的确定。 目前阶段，你可以简单的使用一个简单的链表或者数组来保存已声明变量的信息。 偏移量确定 变量的偏移量有一种比较暴力的设定方式：每一个声明的变量偏移依次递增。目前我们没有作用域，这样做是没问题的，但在第7章引入作用域后，这种暴力的实现会出现一些问题。 变量重复声明的检查：每次碰到生命则检查有无同名变量已经声明。 变量赋值 代码生成 目前只有变量才能作为左值，所以记得检查 assign 操作的类型（或许你已经在 parser 中进行了检查）。因为我们的变量相当于一个地址，可以通过 sd 指令完成变量赋值。 visitAssign(Node assign) { visit(assign.rhs); //计算变量值，结果压入栈中 emitStore(assign.lhs.offset); //进行赋值 } void emitStore(int offset) 生成如下代码： lw t0, 0(sp) addi sp, sp, 4 #pop 变量值 sw t0, 4*{offset}(fp) #变量赋值 addi sp, sp, -4 sw t0, 0(sp) #push 变量值，因为 assign 语句是有返回值的 显然，这段代码可以优化，不做赘述。 注意，assign 语句存在返回值，也就会最终在栈中留下一个值。 因此， a = 0; 语句会给 a 赋值并在栈中留下一个 0，必须将这个多余的值弹出。 \\ ::= \\ \";\" 类型的 statement 都存在这个问题。 变量引用 要引用表达式中的变量，只需将其从堆栈中复制到栈顶即可： visitVar(Node var) { emitLoad(var.offset); } emitLoad(var.offset)： lw t0, 4*{offset}(fp) #取变量的值 addi sp, sp, 4 sw t0, 0(sp) #push到栈顶 "},"docs/lab5/part4-1-task.html":{"url":"docs/lab5/part4-1-task.html","title":"任务","keywords":"","body":"☑任务 更新你的代码生成阶段： 生成函数前序和函数收尾 为变量声明、变量赋值和变量引用生成正确的代码 新的编译器应该在测试集的step[1-5]中的所有例子中成功。 "},"docs/lab5/summary.html":{"url":"docs/lab5/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab5/spec.html":{"url":"docs/lab5/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step5 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement* '}' type : 'int' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step5 语义规范 5.1. 变量重复声明是错误，使用未声明的变量也是错误。 5.2. 被声明的变量在声明语句完成后，可以被使用。 不能写 int a = a。 5.3. （局部）变量初始值不确定，使用不确定的值是未定义行为。 5.4. 执行完 main 函数但没有通过 return 结束时，返回值默认为 0。 5.5. 只有左值能出现在赋值号 = 的左边。 表达式被称为左值（lvalue）当且仅当它能被下面两条规则构造出来： 被声明过的变量是左值； 如果 e 是左值，那么括号括起的 (e) 也是左值。 "},"docs/lab6/part0-intro.html":{"url":"docs/lab6/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab6/part1-parse.html":{"url":"docs/lab6/part1-parse.html","title":"词法语法分析","keywords":"","body":"词法语法解析 分支语句 本步骤对语句的定义做如下修改： ::= \"int\" Identifier \"(\" \")\" \"{\" { } \"}\" ::= | ::= \"int\" Identifier [ \"=\" ] \";\" ::= \"return\" \";\" | \";\" | \"if\" \"(\" \")\" [ \"else\" ] 最主要的变更是引入了分支语句作为一种 ，其中的 \"if\" 和 \"else\" 是新的关键字，应在词法分析器中实现。 值得注意的是：上一步骤中的 被拆分成了 和 两个符号，局部变量的定义不再是一种 了。而 和 都是 。考虑如下例子，你就能明白这一变动的原因。 if (1) x = x + 1; 这是合法的，x = x + 1 是一个 。 if (1) int x; 这是不合法的，int x 是一个 。 语法解析器应生成相应的 AST 结点： statement = ... // 已有的其他结点 | Conditional(exp, statement, statement option) 其中 Conditional 结点表示分支语句，其三个参数分别为分支条件、then 语句和 else 语句，其中 else 语句是可选的。 根据你的喜好，你也可以选择不在 Conditional 结点里实现可选的 else 参数，而是构造一个表示空语句的结点（或者使用下一步要引入的空语句块）来表示缺少 else 分支的情况。 你可以让 Declaration 结点不再属于一种 statement，以和文法保持一致，也可以不做此项修改。 分支表达式 本步骤对表达式的定义做如下修改： ::= Identifier \"=\" | ::= [ \"?\" \":\" ] // ::= { \"||\" } ::= { \"&&\" } ::= { (\"!=\" | \"==\") } ::= { (\"\" | \"=\") } ::= { (\"+\" | \"-\") } ::= { (\"*\" | \"/\") } ::= \"(\" \")\" | | Integer | Identifier ::= \"!\" | \"~\" | \"-\" 此处 表示 ?: 表达式。语法解析器应生成相应的 AST 结点： exp = Assign(string, exp) | Var(string) | BinOp(binary_operator, exp, exp) | UnOp(unary_operator, exp) | Constant(int) | CondExp(exp, exp, exp) // 其中 CondExp 表示 ?: 表达式，其三个参数分别为条件、条件成立时的值，和条件不成立时的值。 "},"docs/lab6/part1-1-task.html":{"url":"docs/lab6/part1-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新你的parse函数，使其可以为所有有效的step6测试用例建立正确的AST。 "},"docs/lab6/part4-codegen.html":{"url":"docs/lab6/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 基础 不妨先看看跳转语句的 c 汇编代码： int main() { int a = 0; if(a) { a = 2; } else { a = 3; } return a; } .globl main main: addi sp,sp,-32 sd s0,24(sp) #这里的 s0 是 fp 的别称 addi s0,sp,32 #函数前序，由于只有一个函数，未保存 ra sw zero,-20(s0) #变量初始化 lw a5,-20(s0) sext.w a5,a5 #这两句计算了 if 条件 beqz a5,.L2 li a5,2 #then 分支 sw a5,-20(s0) j .L3 .L2: #els分支 li a5,3 sw a5,-20(s0) .L3: lw a5,-20(s0) mv a0,a5 #返回变量 a 的值 ld s0,24(sp) addi sp,sp,32 jr ra #函数收尾 跳转语句 跳转语句是分支的基础，跳转分无条件跳转和条件跳转 j label #jump;无条件跳转到label, pc 标识 标识(label)可以方便我们进行跳转，为了保证跳转的正确我们需要合适的方式生成 label。最简单的，我们可以用一个累加的数字来区分 label(比如上面的汇编例子)，但好的 label 可以是的代码更加可读，有些时候也能方便我们编程。目前，我们可以用一个累增数字和一个后缀(.then、.else、.exit)来生成标识。 生成 为了生成 IF 语句和条件表达式的汇编代码，我们将需要有条件和无条件的跳转，以条件表达式为例。遵循递归的思路，我们可以这样 IF 语句: 生成IF语句： 计算条件; 生成跳转语句; 生成标识(then); 生成then分支代码; 生成标识(els); 生成els分支代码; 条件表达式与之类似，以下给出条件表达式伪代码。 visitTern(Node tern) { visit(tern.cond); #Label then = new Label(\"then\"); #在这里，then分支是用不到的，可以删掉，但在后续的循环中会用到 Label els = new Label(\"els\"); #得到一个新的 else label Label exit = new Label(\"exit\"); #得到一个新的 exit label emitBeqz(els); #消耗 tern.cond 的结果，如为 false 则跳转到 els 分支 then.emit(); #emit then label, 接下来的代码会 push then 分支的结果并跳转到 exit emitJ(exit); #then分支结束后，直接跳转到 exit label els.emit(); #emit els label, 接下来的代码会 push els 分支的结果并跳转到 exit visit(tern.els); exit.emit(); } IF 语句与条件表达式很类似，请同学们自行完成。 "},"docs/lab6/part4-1-task.html":{"url":"docs/lab6/part4-1-task.html","title":"任务","keywords":"","body":"☑任务 更新代码生成过程，以正确处理三元条件表达式和if语句。它应该在所有step[1-6]的例子上成功。 （可选）改写 RET 尝试改写你的 return 语句生成，是其不会直接返回而是跳转到函数收尾，这为处理函数打下来基础。 （思考）条件表达式短路 在part4的实现中，条件表达式存在短路现象。即： int main() { int a = 0; int b = 0 ? 1 : (a = 2); return a; } 会返回 0 而不是 2。为什么会这样，如果要求不存在短路现象，该如何修改？简述你的思路。 "},"docs/lab6/summary.html":{"url":"docs/lab6/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab6/spec.html":{"url":"docs/lab6/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step6 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' block_item* '}' type : 'int' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step6 语义规范 6.1. int 类型的表达式作为 if 或条件表达式的条件时，非 0（例如 1、-1、1000000007）表示真，0 表示假。 6.2. 如果出现悬吊 else（dangling else），要求 else 优先和内层 if 结合。 例如 if (0) if (0) ; else ; 等价于 if (0) { if (0) ; else; } 而非 if (0) { if (0) ; } else ;。 6.3. if 的 then 子句和 else 子句不能仅是一个声明，编译器应当报错错误。 例如 if (1) int a; 是不合法的输入 6.4. 和 2.3 不同，条件表达式规定了子表达式的求值顺序。 首先对条件求值。如果条件值为真，然后仅对 ? 和 : 之间的子表达式求值，作为条件表达式的值， 不得对 : 之后的子表达式求值。 如果条件为假，类似仅对 : 之后的子表达式求值。 "},"docs/lab7/part0-intro.html":{"url":"docs/lab7/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab7/part1-parse.html":{"url":"docs/lab7/part1-parse.html","title":"词法语法分析","keywords":"","body":"词法语法解析 本步骤对词法/语法解析的变更较为简单。语句块可以视为语句的一种，就像括号表达式可以视为表达式的一种一样。 据此，文法做如下修改： ::= | ::= \"int\" Identifier [ \"=\" ] \";\" ::= ... // 已有的其他产生式 | \"{\" { } \"} // 你可能需要加入其他标记与产生式以识别 { }。 要生成的 AST 做如下修改： statement = ... // 已有的其他结点 | Compound(block_item list) "},"docs/lab7/part1-1-task.html":{"url":"docs/lab7/part1-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新你的parse函数，使其可以为所有有效的step7测试用例建立正确的AST。 "},"docs/lab7/part4-codegen.html":{"url":"docs/lab7/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 块语句本身的汇编生成是很简单的，只需要依次生成块中的语句即可，块语句真正影响的是变量。 正如测试例子中的某些程序，有可能有两个不同的变量，在两个不同的作用域中，存储在栈的两个不同的位置，但名称相同。下面是这样一个例子： int foo = 3; { int foo = 4; } 因此，每当程序引用变量foo时，我们生成的代码就需要在栈上访问正确的foo，如果foo已经“死亡”，则会引发一个错误。本次试验的代码生成步骤就是管理和访问变量集合对应的数据结构，使我们总是能查找到正确的foo。为此，我们需要调整我们在变量定义、赋值、引用时的行为。 变量偏移的确定 回顾我们在 lab5 中的做法，变量偏移完全等于变量出现的次序。这在当前仍然是正确的，但比较浪费栈空间，因为变量都存在生命周期，有些变量不可能同时存在，也就可以共用同一块地址空间（这个问题在后续编译课程中有深入的讨论）。我们在这里不做过多的优化，但在 minidecaf 中，一旦离开一个作用域，该作用域中声明的变量会全部失效，这就可以引出一个简单而有效的优化：利用栈的形式存储变量，记录作用域（只纪作用域深度即可），碰到变量声明则压栈变量，一旦离开一个作用域则弹出该作用域中所有的变量，此时，变量的偏移可以设置为它在栈中的位置编号（想想为什么？）。 找到正确变量 在 lab5 中，因为只有一个作用域，不论赋值还是引用，我们直接遍历所有变量就可以找到目标变量，但是引入作用域后，找到正确变量就没那么简单了。 所谓正确的变量，指的是位于同一或者各级父作用域中，最接近变量引用的声明，也就是“最近”的变量声明。 在单遍的代码生成中，可以维护上一小节所描述的变量栈，直接在栈中从栈顶向栈底搜索即可。这样，总是会找到最近的变量声明，且已经“死亡”的变量会被弹出，不会找错。 在多遍的代码生成中，我们可以维护一个树状的结构来维护变量的声明以及作用域信息。提示：可以通过存储声明位置（行号、列号，这要求生成的 AST 中存储了这些信息）判断同一个作用域中的某一个声明位于引用前还是引用后（step7/declare_late.c）。 "},"docs/lab7/part4-1-task.html":{"url":"docs/lab7/part4-1-task.html","title":"任务","keywords":"","body":"☑任务 更新代码生成阶段的代码，以正确处理复合语句。并在step[1-7]中的例子上成功。 "},"docs/lab7/summary.html":{"url":"docs/lab7/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab7/spec.html":{"url":"docs/lab7/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step7 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step7 语义规范 7.1. 不得声明当前作用域已经声明过的同名变量。 7.2. 声明某变量时，只要当前作用域没有同名变量，那么声明即合法。 并且从此声明开始，到它所在作用域结束，其变量名都被绑定到该声明上，而非某个更早的开作用域中的声明。 7.3. 使用不在当前开作用域中的变量名是不合法的。 "},"docs/lab8/part0-intro.html":{"url":"docs/lab8/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab8/part1-parse.html":{"url":"docs/lab8/part1-parse.html","title":"词法语法分析","keywords":"","body":"词法语法解析 while 语句 为 新增如下产生式： ::= ... // 已有的其他产生式 | \"while\" \"(\" \")\" 其中 \"while\" 是新的标记，应在词法分析器中实现。 新增如下 AST 结点： statement = ... // 已有的其他结点 | While(expression, statement) 其中 expression 和 statement 分别为循环条件和循环体。 do while 语句 为 新增如下产生式： ::= ... // 已有的其他产生式 | \"do\" \"while\" \"(\" \")\" \";\" 其中 \"do\" 是新的标记，应在词法分析器中实现。 新增如下 AST 结点： statement = ... // 已有的其他结点 | Do(statement, expression) 其中 expression 和 statement 分别为循环条件和循环体。 for 语句 相对于 while 语句和 do while 语句，for 语句较为复杂。for 语句可能有如下变种： for 的第一个分号前，可能是语句，也可能是循环变量的定义； for 的初始化语句、循环条件和自增语句均可以为空。 为此，我们按如下方式设计文法： ::= ... // 已有的其他产生式 | \"for\" \"(\" | \"for\" \"(\" ::= \";\" | \";\" ::= \")\" | \")\" 其中 \"for\" 是新的标记，应在词法分析器中实现。 当然，这只是能解析 for 语句的其中一种文法。你也可以设计一个标记表示“表达式或空”，以替换 和 ，或是按你喜欢的其他方式设计。 解析器应生成如下 AST 结点： statement = ... // 已有的其他结点 | For(exp option, exp option, exp option, statement) | ForDecl(declaration, exp option, exp option, statement) 其中 For 和 ForDecl 分别表示在 for 语句中使用初始化语句和定义循环变量的两种情况。AST 结点的各个参数分别表示初始化语句/循环变量定义、循环条件、自增语句和循环体。如果你在第6步选择将 Declaration 作为一种 statment，那么只需添加 For 结点即可，而不必添加 ForDecl 结点。按这种方式，你可能需要在后续步骤中区分这两种 for 语句。 带 option 标记的表示该项是可选的。你也可以选择不在 AST 结点中设计可选参数，而是构造一个常量 1 结点代替空的循环条件、构造一个空语句块结点代替空的初始化或自增语句。 空语句 在本步骤中，我们还要引入空语句。你可以利用上述 for 语句产生式中的 ，例如： ::= ... // 已有的其他产生式 | // null statement 也可以设计单独的空语句产生式。 对于 AST，你既可以使用空的语句块结点表示空语句，也可以加入专门表示空语句的结点，还可以干脆不用任何结点表示空语句。 break 和 continue 语句 为 新增如下产生式： ::= ... // 已有的其他产生式 | \"break\" \";\" | \"continue\" \";\" 其中 \"break\" 和 \"continue\" 均是新的标记，应在词法分析器中实现。 新增如下 AST 结点： statement = ... // 已有的其他结点 | Break | Continue 值得注意的是，如果程序中存在位于循环体外部的 break 或 continue，上述文法并不会报错。你需要在后续步骤中进行验证，也可以改进文法，在语法解析阶段就识别此类错误。 "},"docs/lab8/part1-1-task.html":{"url":"docs/lab8/part1-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新你的parse函数，使其可以为所有有效的step8测试用例建立正确的AST。 "},"docs/lab8/part4-codegen.html":{"url":"docs/lab8/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 空语句 对于空语句的代码生成过程很简单，即不要为空语句生成任何汇编。 while 循环 给定一个 while 循环： while () 我们可以这样描述它的代码生成流程： 生成计算 的代码 如果结果是假的，跳到步骤 5 生成 的代码 跳到步骤 1 完成 在这里就不展示需要生成的具体汇编了，参考 RISC-V 指令集选取合适的指令（条件跳转和无条件跳转）。最主要的是给步骤 1 和步骤 5 打上标签（label），这样当我们需要跳转指令时，就有地方可以跳转了。 do 循环 对于一个 do 循环： do while (); 和 while 循环不同，do 循环会先执行循环体 ，再计算 的值，如果结果为真，才跳转到循环体头部，否则不跳转而结束循环。请参考 while 循环实现 do 循环的代码生成。 for 循环 给出这样一个 for 循环： for (; ; ) 可以转换成如下的 while 循环： while () { } 类似地，for 循环也可转换为一个 do 循环，不过需要增加 后直接跳转到计算 这一步。因此，你可以直接复用 while 循环或 do 循环的代码生成过程，为 for 循环生成代码。 需要注意的是， 和 都有可能是空的，在这种情况下，我们只是不生成任何汇编。对于 为空的情况，还需修改相应的条件跳转语句。 break 和 continue 语句 我们可以用一条直接跳转指令实现这两条语句，关键是找出跳转到哪里： break：跳转到“循环结束”标签； continue： 对于 while 循环：跳转到计算 前面； 对于 do 循环：跳转到生成 前面； 对于 for 循环：跳转到生成 前面； "},"docs/lab8/part4-1-task.html":{"url":"docs/lab8/part4-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新汇编代码生成过程，以正确处理三种循环语句以及 break、continue 语句。并通过 step[1-8] 的测试用例。 "},"docs/lab8/summary.html":{"url":"docs/lab8/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab8/spec.html":{"url":"docs/lab8/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step8 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step8 语义规范 为方便，我们称 for 括号中的三个表达式/声明为：init（或 pre）、ctrl、post。 例如 for (i=0; i 中，i=0 是 init，i 是 ctrl，i=i+1 是 post。 8.1. for 循环的控制表达式可以为空，表示循环条件永远为真。 8.2. for 语句自身带一个作用域，给作为 init 的声明用。 如果 for 的循环体是 block 语句块，那么循环体再带一个作用域。 因此 for (int i=0;;i=i+1) { int i=1; return i; } 是合法代码。 8.3. 在循环外使用 break 和 continue 是错误行为。 8.4. break 跳转至最近的循环的结束后第一条语句。 8.5. 如果最近的循环语句是 do 或 while，continue 跳转到执行条件判断； 如果是 for，continue 跳转到执行 post（然后再计算循环条件、结束/继续循环……）。 "},"docs/lab9/part0-intro.html":{"url":"docs/lab9/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab9/part1-parser.html":{"url":"docs/lab9/part1-parser.html","title":"词法语法分析","keywords":"","body":"词法语法分析 本步骤引入了函数调用的概念。和之前只允许主函数定义不同，在本步骤中你将修改之前的文法规定，允许在一个源程序中声明和定义多个函数，并支持对它们的调用。 注：因词法分析部分需要解释的东西较少，我们将词法和语法分析合为一个文件，但需要注意的是，它们是相互独立的操作流程。 词法分析 你需要添加逗号,来支持函数参数的分隔，目前的 Token 列表为： { } ( ) ; int return Identifier [a-zA-Z_][a-zA-Z0-9_]* Integer literal [0-9]+ - ~ ! + * / && || == != >= = if else : ? for while do break continue , // 语法分析 和之前的步骤不同，本步骤添加了对函数调用的支持，因此我们需要处理函数定义以及函数调用。 函数定义 在此前的步骤中，我们将一个源文件限制为只可定义一个函数并且函数的声明和定义不可分离，文法如下： ::= ::= \"int\" Identifier \"(\" \")\" \"{\" { } \"}\" 为了实现正常的函数定义，你首先需要添加函数参数列表，支持带参数的函数： ::= \"int\" Identifier \"(\" [ \"int\" Identifier { \",\" \"int\" Identifier } ] \")\" 其次，你需要支持函数的声明和定义分离这一特性。函数声明指在使用该函数前说明其函数名、参数列表以及返回类型，而函数定义指包含函数体的一个完整函数单元，如下例所示，我们首先声明了foo函数，并在之后给出了foo函数的定义。 int three(); int three() { return 3; } 综上，为了支持函数参数、函数的声明与定义，可以将文法修改为如下所示： ::= \"int\" Identifier \"(\" [ \"int\" Identifier { \",\" \"int\" Identifier } ] \")\" ( \"{\" { } \"}\" | \";\" ) 注：原则上同一个函数可以声明无数次，但只能定义一次。本实验中对于同名函数的重复声明不做要求，即属于未定义行为，测例中不会出现同名函数重复声明的情况。 函数调用 函数调用是一个类似这样的表达式： foo(arg1, arg2, ...) 它包含了函数名和一个参数列表，和函数声明不同，参数可以为任意形式的表达式，因此我们在处理时将函数名作为Identifier元素，参数作为exp元素进行处理，语法解析器生成相应的AST节点： exp = ... | FunCall(string, exp list) // string is the function name ... 和前面的步骤一样，作为表达式，函数调用也应该有其优先级，一般函数调用具有尽可能高的优先级，因此在文法中，我们将其添加到规则中： ::= Identifier \"=\" | ::= [ \"?\" \":\" ] ::= { \"||\" } ::= { \"&&\" } ::= { (\"!=\" | \"==\") } ::= { (\"\" | \"=\") } ::= { (\"+\" | \"-\") } ::= { (\"*\" | \"/\") } ::= | \"(\" \")\" | | Integer | Identifier ::= id \"(\" [ { \",\" } ] \")\" // ::= \"!\" | \"~\" | \"-\" "},"docs/lab9/part1-1-task.html":{"url":"docs/lab9/part1-1-task.html","title":"任务","keywords":"","body":"☑任务： 词法分析 我们需要添加逗号来分隔函数参数，因此你需要在你的 Token 识别中增加对逗号,的支持。 语法分析 更新你的parse函数，使其可以为所有有效的step9测试用例建立正确的AST，并保证之前的测试用例不被影响。 "},"docs/lab9/part4-1-cconv.html":{"url":"docs/lab9/part4-1-cconv.html","title":"调用约定","keywords":"","body":"调用约定 增加了函数之后，需要修改的部分主要有两处：函数定义与函数调用。在生成汇编代码之前，我们需要先了解一下调用约定。 调用约定（calling conventions）可认为是函数调用与函数定义之间规定的一套协议，只要双方都遵循同样的协议，调用就不会出错。如果两个编译器使用的调用约定相同，它们就可以互相调用各自编译出的函数，例如要让我们的 minidecaf 程序正确调用已编译的 C 标准库的函数，就需要让我们的编译器遵循 GCC 的调用约定。 总的来说，调用约定统一了以下有关函数调用的接口： 参数是如何传递给被调用者（callee ）的？是在栈上还是寄存器上传递？ 返回值是如何传回给调用者（caller ）的？ 调用者与被调用者之间如何协调管理栈空间？ 哪些寄存器由调用者保存？哪些由被调用者保存？ 调用约定没有一套统一的标准，例如对于 x86 架构就有 cdecl、stdcall、fastcall 等多种。为了便于实现，在这里我们介绍了一套 RISC-V 的简化版调用约定，你也可以参考 GCC 的，或自己定义一套。 我们的调用约定可以概况为： 参数都通过栈传递，压栈顺序为从右向左。 返回值保存在 a0。 调用者分配和回收参数所需的栈空间，被调用者分配和回收自己的栈帧。 除了有特殊用途的寄存器外，t0-t6 是由调用者保存的，s0-s11 是由被调用者保存的。 以下是一些细节。 RISC-V 寄存器 图片来源：https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf 上表列出了 RISC-V 架构的所有整数寄存器和浮点寄存器。由于寄存器个数是有限的，因此它们常常需要被保存到内存中。寄存器的保存通常发生在函数调用前后，根据保存者的不同，寄存器可分为调用者保存（caller saved）寄存器和被调用者保存（callee saved）寄存器（见上表最后一列）： 调用者保存寄存器（或临时寄存器）：在函数调用前，由调用者将它们保存到栈上，并在函数调用结束后从栈上恢复，在调用前后可能被修改； 被调用者保存寄存器（或保存寄存器）：在函数调用开始后，由被调用者将它们保存到栈上，并在函数返回前从栈上恢复，在调用前后保持不变。 例如，以 t 开头的寄存器都是临时寄存器，在函数调用时不保留，如果调用后还要用到则需要调用者进行保存；用于存放返回值或参数的以 a 开头的寄存器也会在函数调用时被更改，也属于临时寄存器。而以 s 开头的寄存器都是保存寄存器，在函数调用时会保留原来的值，调用者无需进行保存；另外如 sp 之类的寄存器因在函数调用前后保持不变，也属于保存寄存器。 由于本实验不包含寄存器分配和浮点运算，我们只会用到其中很小的一部分： 函数返回地址 ra 栈指针 sp 栈帧指针 fp（或 s0） 临时寄存器：t0-t1（两个足够） 函数返回值 a0 参数寄存器 a0-a7（如果实现了寄存器传参） 参数传递 一般来说，为了提高性能，参数应尽可能通过寄存器传递。不过为了简单起见，我们规定参数全部使用栈来传递。你完全可以遵循其他调用约定使用 a0-a7 寄存器来传参，或是当参数个数过多时同时使用寄存器和栈来传参。 当函数调用开始前，调用者按从右到左的顺序将每个参数压入栈中。例如，对于函数调用 foo(1, 2, 3); 压栈的顺序是： PUSH 3 PUSH 2 PUSH 1 当函数调用结束后，再由调用者释放栈上的这段参数空间。 "},"docs/lab9/part4-2-codegen.html":{"url":"docs/lab9/part4-2-codegen.html","title":"代码生成","keywords":"","body":"代码生成 首先确定你要遵循的调用约定，你可以使用上一节中我们给出的简化版调用约定，也可以参考 GCC 的，也可以自己再定义一套。不过，你的编译器应该始终遵循同一套调用约定。本小节之后的描述都基于上一节的简化版调用约定。 函数序言 在 lab4 我们简单提及了函数的序言（prologue）与收尾（epilogue），这里我们将对这两部分代码的生成进行完善。 当一个函数开始执行前，需要做一些额外工作，即函数序言，这一部分的工作包括： 创建栈帧：根据局部变量和需要保存的寄存器的个数，栈帧的大小是可以事先确定的，直接令 sp 减去栈帧大小。在某些系统下，需要让栈指针 16 字节对齐，不过本实验中我们将其省略。 保存寄存器：在这一部分需要保存的寄存器即被调用者保存寄存器，在 RISC-V 中即以 s 开头的那些寄存器，不过在本实验中我们只用到了 s0（即 fp），所以不需要保存其他的。特别地，如果在该函数中调用了另一个函数，返回地址寄存器 ra 也会被修改，我们也将它保存在这里，但它其实是属于调用者保存寄存器。 设置栈帧指针：函数中用到的所有局部变量都是保存的栈帧中的，我们可以通过“栈帧基址寄存器”加“偏移”的形式来引用它们。不过我们不能直接使用 sp 作为栈帧基址寄存器，因为在后续栈式机的执行过程中栈可能会增长。这里我们用一个特殊寄存器 fp（等价于 s0）来保存栈帧基址，即栈帧指针（frame pointer），并将其设为原来的 sp。 生成的代码如下： .globl func: # 设置标签 func 为全局可见 func: # 函数入口标签 addi sp, sp, -framesize # 创建栈帧 sw ra, framesize-4(sp) # 保存函数返回地址 sw fp, framesize-8(sp) # 保存上一函数栈帧指针 addi fp, sp, framesize # 设置新的栈帧指针 函数收尾 当一个函数运行结束，执行 return 语句后，还不能直接返回，还需要一些收尾工作，即函数收尾。这一部分的工作包括： 恢复寄存器：恢复那些在序言部分保存的寄存器，即返回地址 ra 和栈帧指针 fp。 销毁栈帧：令 sp 加上栈帧大小，保证 sp 在函数调用前后不变。 设置返回值并返回：将 return 语句中的返回值保存到 a0 寄存器，然后执行 ret 指令。 生成的代码如下： func_epilogue: # 函数收尾部分标签 lw ra, framesize-4(sp) # 恢复函数返回地址到 ra lw fp, framesize-8(sp) # 恢复上一函数栈帧指针到 fp addi sp, sp, framesize # 销毁栈帧 mv a0, retval # 将返回值保存到 a0 寄存器 ret # 等价于 jr ra 此外，在之前的 lab4 也提到过，对于所有的 return 语句，应该生成一条直接调转到函数收尾的语句，而不是直接一条 ret 指令。 函数调用 这里需要用到一条新指令 call label，其原型为 jal ra, label，表示“跳转到 label，并把返回地址保存到 ra”，而 call 只是一条伪指令。 当要调用一个函数时，不光是一条 call 指令就可以解决的，还需要考虑以下方面： 参数传递：根据我们的调用约定，使用栈从右往左进行传参。 寄存器的保存与恢复：我们需要在函数调用前保存调用者保存寄存器，并在调用结束后恢复。不过本实验使用栈式机模型，没有寄存器的分配，在栈式机执行过程中已经进行了寄存器的保存，因此无需专门保存调用者寄存器。 于是对于函数调用，我们可以生成以下汇编代码： addi sp, sp, -arg_num*4 # 在栈上分配一块区域用于存放参数 sw arg_n-1, n*4-4(sp) # 从右向左依次向栈中压入参数 ... sw arg_1, 4(sp) sw arg_0, 0(sp) call func # 调用函数 func，硬件会自动设置 ra 为下一条指令的地址 addi sp, sp, arg_num*4 # 回收栈空间 addi sp, sp, -4 sw a0, 0(sp) # 将返回值压入栈，继续栈式机的执行 需要注意，在函数 func 中引用参数时，要能确定参数的位置，即算出正确的相对于 fp 的偏移。 栈空间布局 为了方便理解，这里给出了函数调用时的栈空间布局，以供参考： "},"docs/lab9/part4-3-task.html":{"url":"docs/lab9/part4-3-task.html","title":"任务","keywords":"","body":"☑任务： 更新汇编代码生成过程，以正确处理函数定义与调用。并通过 step[1-9] 的测试用例。 ☑任务（可选）： 利用 riscv64-unknown-elf-gcc，通过对一些小例子生成汇编代码，了解 GCC 的调用约定，包括函数序言、函数尾声、函数调用部分，并改进你的 minidecaf 编译器，使其符合 GCC 的调用约定，并让 minidecaf 程序能够正确调用由 GCC 编译的函数。 下面是一个测试程序，使用你的编译器编译并运行后，应该能正确输出 Hello, World!。 int putchar(int c); int main() { putchar(72); putchar(101); putchar(108); putchar(108); putchar(111); putchar(44); putchar(32); putchar(87); putchar(111); putchar(114); putchar(108); putchar(100); putchar(33); putchar(10); } 提示：使用 a0-a7 寄存器传递前 8 个参数，超过 8 个的部分再使用栈传递，并注意传参寄存器的保存。 "},"docs/lab9/summary.html":{"url":"docs/lab9/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab9/spec.html":{"url":"docs/lab9/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step9 语法规范 灰色部分表示相对上一节的修改。 program : function* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier step9 语义规范 9.1. main 默认返回 0，但如果其他函数也没有 return，则它们的返回值未定义。 如果程序尝试使用这个未定义的返回值，那么产生一个未定义行为。 当然，如果程序忽略它，那是合法的。 我们没有支持 void 返回值，但可以忽略返回值达到类似的效果。 9.2. 每个函数只能被定义一次，在定义之前可能有一次前置声明。 多次声明一个函数、以及定义后再声明，均是未定义行为。 多次定义一个函数是错误。 9.3. 函数声明和定义的参数个数、同一位置的参数类型、以及返回值类型必须相同。 现在只有 int 类型，不过以后会有更多类型。 9.4. 调用某函数时，实参和形参的参数个数必须相同，同一位置的参数类型也必须相同。 "},"docs/lab10/part0-intro.html":{"url":"docs/lab10/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab10/part1-parser.html":{"url":"docs/lab10/part1-parser.html","title":"词法语法分析","keywords":"","body":"词法语法分析 本步骤引入了全局变量的概念。这意味着你可以将变量声明和初始化放在函数外进行，在本步骤中你将修改之前的文法规定，支持全局变量的声明和初始化。 注：因词法分析部分需要解释的东西较少，我们将词法和语法分析合为一个文件，但需要注意的是，它们是相互独立的操作流程。 词法分析 本步骤无新增 Token 定义，目前的 Token 列表为： { } ( ) ; int return Identifier [a-zA-Z_][a-zA-Z0-9_]* Integer literal [0-9]+ - ~ ! + * / && || == != >= = if else : ? for while do break continue , 语法分析 本步骤新增了对于全局变量的支持，因此现在位于最顶层的声明有函数声明和变量声明两种，之前的顶层声明需要加入对变量声明的支持，我们修改文法如下： ::= { } // ::= { | } // 在修改了文法定义之后，我们的顶层 AST 会发生一些变化： // 修改前 AST program = Program(function_declaration list) // 修改后 AST toplevel_item = Function(function_declaration) | Variable(declaration) toplevel = Program(toplevel_item list) program = Program(function_declaration list) "},"docs/lab10/part1-1-task.html":{"url":"docs/lab10/part1-1-task.html","title":"任务","keywords":"","body":"☑任务： 词法分析 本次实验涉及到了全局变量的定义，没有新的 Token 出现，因此无需修改词法分析部分。 语法分析 更新你的parse函数，使其可以为所有有效的step10测试用例建立正确的AST，并保证之前的测试用例不被影响。 "},"docs/lab10/part4-codegen.html":{"url":"docs/lab10/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 全局变量需要保存在内存中的某个地方。它们不能被保存在栈上，因为栈可认为是一个函数的私有数据，其他函数不能进行访问。因此它们需要被保存在一块公共的内存中，即数据段（data section）。我们知道一个程序在运行时有一个自己的地址空间，并被划分为了多段内存区域，不同的段有着不同的读、写、可执行权限，下图给出了不同内存段的布局： 我们之前一直在处理的 RISC-V 指令都在代码段（text section），具有可执行权限，并且是只读的；而全局变量则在数据段（data section），一般具有可读写权限，而无可执行权限。我们可将其进一步细分为初始化、未初始化、以及只读的数据段，其中未初始化的数据段通常称为 BSS，会在程序加载时被初始化为 0；只读数据段（rodata）用于保存程序中定义的常量，在本实验中不会用到。 在编写自己的汇编码生成器之前，我们先来看看 GCC 是如何生成全局变量的代码的。 int N = 2333; int main() { return N; } 使用以下命令编译出汇编代码： $ riscv64-unknown-elf-gcc test.c -O3 -S -o test.S $ cat test.S .file \"test.c\" .option nopic .text .section .text.startup,\"ax\",@progbits .align 1 .globl main .type main, @function main: lui a5,%hi(N) lw a0,%lo(N)(a5) ret .size main, .-main .globl N .section .sdata,\"aw\" .align 2 .type N, @object .size N, 4 N: .word 2333 .ident \"GCC: (SiFive GCC 8.2.0-2019.05.3) 8.2.0\" 全局变量定义 从上述结果中，很容易找到全局变量 N 的定义部分，去掉一些无关内容并简化后如下： .data # 即 .section .sdata,\"aw\"，表示接下来是数据段，内容可写 .globl N # 让符号 N 对链接器可见 .align 2 # 接下来的数据需要 4 字节对齐 N: .word 2333 # 在数据段分配一个字（4 字节）大小的整数，值为 2333 这里有几件事要注意： .data 指示符告诉汇编器我们在数据段。我们还需要一个 .text 指示符来告诉我们何时切换回代码段。 像 N 这样的标签可以标注一个内存地址。汇编器和链接器并不关心这个地址是指代码段的指令还是数据段的变量，它们会以同样的方式处理它。 .align n 的意思是“下一个东西的起始地址应为 2n2^n2​n​​ 字节的倍数”。 有关 RISC-V 汇编指示符（directives）的更多内容 ，详见 https://github.com/decaf-lang/minidecaf/blob/master/doc/riscv-assembly-directives.md 在具体实现时，我们每遇到一个全局变量，就生成类似以上的代码。对于未初始化的全局变量，简单起见我们无需考虑 BSS 段，直接将其初始化为 0 即可。 对于全局变量的初值，需要在编译时就进行确定，因此其初始化器需要是一个常量表达式。为了方便，我们的测试集只包含该常量表达式是一个整数的情况，你可以无需计算表达式。 全局变量引用 从 GCC 的结果中我们也可以得到引用一个全局变量的方法： lui a5,%hi(N) # 将 N 地址的高 20 位作为立即数加载到 a5，低 12 位设为 0 lw a0,%lo(N)(a5) # 从内存中读出数据保存到 a0，内存地址为 a5 加上 N 地址的低 12 位 注意到这里用了两条指令，而不是类似 lw a0, 0(N) 的一条，这是因为 N 在这里是个标签，其实际值是一个 32 位的地址，这超过了一条长度为 4 字节的指令的表示能力。 对于给全局变量赋值的情况也类似，只不过是把 lw 换成了 sw。 "},"docs/lab10/part4-1-task.html":{"url":"docs/lab10/part4-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新汇编代码生成过程，以正确处理全局变量的定义与引用。并通过 step[1-10] 的测试用例。 ☑任务（可选）： 将未初始化的全局变量放到 BSS 段。 ☑任务（可选）： 大多数编译器允许用常量表达式来初始化全局变量，比如： int foo = 2 + 3 * 5; 这需要你在编译时就算出 2 + 3 * 5 的值。改进你的编译器以支持这一点。 "},"docs/lab10/summary.html":{"url":"docs/lab10/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab10/spec.html":{"url":"docs/lab10/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step10 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier step10 语义规范 10.1. 全局变量可以被初始化，但初始值（initializer）只能是整数字面量。 10.2. 如果没有显式给出初始值，全局变量初始值为 0。 10.3. 不允许重复声明全局变量。 "},"docs/lab11/part0-intro.html":{"url":"docs/lab11/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab11/typeck.html":{"url":"docs/lab11/typeck.html","title":"类型检查","keywords":"","body":"类型检查 …… 类型检查是语义检查 …… 不能 int + int …… …… 类型上下文：变量 -> 类型的映射 …… …… 类型规则：参数类型有哪些 -> 返回值类型 …… "},"docs/lab11/part4-codegen.html":{"url":"docs/lab11/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 本阶段代码生成的重点是处理 * 和 & 这两个运算符，而对于类型系统和强制类型转换属于语义检查，无需生成代码。 首先，对于 * 运算，只需一条 Load 指令即可完成解引用这一操作。但对于取地址符 & 就不是很直观了，因为 & 号后面可能不会立即跟一个变量如 &a，而是会有形如 &*p 这样的，虽然两个操作可以相互抵消，但如果将其解释为“先解引用，再取地址”，就难以生成对应的汇编代码，因为变量的地址信息会在解引用后丢失。此外，对于像 * 号出现在赋值语句左边的情况，也不是很好处理。因此，在讨论如何生成代码之前，我们先来讨论一下“左值”的概念。 左值 我们都知道，赋值语句可以写成 a = 123 的形式，而不能是 123 = a，这是因为赋值号左边的是一个左值（lvalue），要求与一个地址相关联；而右边的 123 是一个右值（rvalue），并不需要关联一个地址。通俗地讲，左值是一个有地址的值，例如： int a; int* p; a = 1; // a 是左值 *&a = 2; // *&a 是左值 p = &a; // p, a 是左值 *p = 3 + a; // *p 是左值 从上述代码可以看出，赋值号左边的以及 & 后面的都要求是左值，需要知道它们的地址才能进行计算；而像几个常量和最后一行的 a 这样的是右值，只需知道其值就行了。 有了左值的概念，就比较容易处理本节一开始提到的哪些问题了。例如对于 &a 和 &*p，可看做求左值 a 和 *p 的地址（不考虑空指针，*p 的地址就是 p 的值），对于赋值 *p = 1，可以看做先求左值 *p 的地址，再向该地址写入 1。 因此，在生成代码的过程中，对于左值，我们不能生成其具体的值，而要先生成它们的地址。对于一个表达式，我们需要先确定那些部分是左值，并求得它们的地址作为中间结果，然后才能生成正确的代码。通过观察，我们可以归纳出左值的判定方法： 出现在赋值号 = 的左边，或是取地址符 & 的右边； 是一个标识符，或是 * 开头的表达式（(*p) 等有括号的形式也算）。 在建立了 AST 后，我们可以很容易求出哪些节点是左值，可将其作为节点的属性，以供之后使用。 此外，我们还需要进行左值检查，以拒绝编译形如 123 = a 的错误输入。根据上述左值的判定方法，如果表达式的某一部分满足第 1 条，但不满足第 2 条，就是不合法的。 基于左值的代码生成框架 现在，我们假设已经求出了 AST 的哪些节点是左值。在之后的遍历 AST 生成汇编码时，只需对左值生成地址，对右值生成值。在我们的文法中，左值一定出现在 非终结符，其文法为： ::= Identifier | '*' | '&' | ... 下面给出了用于生成汇编码的伪代码： function visitFactor(ctx) { if (ctx ::= Ident) { // ::= Identifier emitAddress(Ident); // 计算变量 Ident 的地址 if (ctx.isLValue) { // do nothing // 如果是左值，直接返回其地址 } else { emitLoad(); // 否则，再生成一条 Load 指令来取得变量的值 } } else if (ctx ::= '*' factor) { // ::= '*' visitFactor(factor); // 访问子 factor 计算其值 if (ctx.isLValue) { // do nothing // 如果是左值，直接返回该值 } else { emitLoad(); // 否则，再生成一条 Load 指令来解引用 } } else if (ctx ::= '&' factor) { // ::= '&' visitFactor(factor); // 子 factor 一定是左值，直接访问以得到其地址 } else { // ... } } 生成左值的地址 如上一节所述，左值只可能出现在两种地方： 标识符：地址即该变量的地址； 解引用符 * 之后：地址即之后那部分的值； 第二种情况可直接忽略，我们只需考虑如何计算一个变量的地址。在上一个 lab 我们引入了全局变量，所以变量可分为两种： 局部变量：保存在栈上，使用 lw t0, offset(fp) 指令获取其值。由于我们使用栈来传参，所以参数也可认为是局部变量。 全局变量：保存在数据段，使用 lui t1, %hi(N); lw t0, %lo(N)(t1) 指令获取其值。 要从取值变成取地址，只需将 lw 改成 addi： addi t0, fp, offset # 获取局部变量的地址，保存到 t0 lui t1, %hi(N) addi t0, t1, %lo(N) # 获取全局变量 N 的地址，保存到 t0 之后，可再用一条 Load 或 Store 指令来实现获取变量的值或给变量赋值： lw t1, 0(t0) # 读取内存地址 t0 中的内容到 t1 sw t1, 0(t0) # 将 t1 写入内存地址 t0 赋值语句 最后，我们还需要修改赋值语句的生成过程。在之前的语法分析阶段，赋值语句的文法已经改为了 - ::= Identifier \"=\" | + ::= \"=\" | 其中要求 是一个左值。 我们在之前生成赋值语句时是这么做的： 生成 expr 的代码 # 结果存在 t0 sw t0, offset(fp) # offset 为变量在栈帧中的位置 现在，已经没有变量了，而是变成了左值。我们就先生成计算左值地址的代码，然后再生成一条 Store 指令即可： 生成 factor 的代码 # 结果（左值的地址）存在 t0 生成 expr 的代码 # 结果存在 t1 sw t1, 0(t0) # 将 t1 写入内存地址 t0 "},"docs/lab11/part4-1-task.html":{"url":"docs/lab11/part4-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新汇编代码生成过程，以正确处理指针运算符。并通过 step[1-11] 的测试用例。 "},"docs/lab11/summary.html":{"url":"docs/lab11/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab11/spec.html":{"url":"docs/lab11/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step11 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' | type '*' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | unary '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!'|'&'|'*') unary | '(' type ')' unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier step11 语义规范 11.1. 左值表达式除了能通过 5.5 中两条规则得到，新增一条规则： 如果 e 是类型为 T* 的表达式，那么 *e 是类型为 T 的左值。 因此 int a; *&a=2; 中 *&a 是左值。 11.2. step11 中类型只有 int 和指针类型。禁止隐式类型转换，但允许显式类型转换，只要不违反其他几条规范。 11.3. & 的操作数必须是左值。 所以 &*e 等价于 e，但它不是左值了 11.4. * 的操作数类型必须是指针类型。 11.5. 指针类型的表达式仅能参与如下运算：类型转换、（一元）&、*、（二元）==、!=。 指针不得参与乘除模和、一元、比较大小、逻辑运算。step12 会支持算术。 11.6. 空指针是值为 0 的指针。 因为禁止隐式类型转换，所以空指针字面量必须由 0 显示转换而来，例如 (int*) 0。 判断空指针类似：if (p == (int**)0) ; 或 if ((int)p = 0) ;。 11.7. 未对齐的指针是未定义行为。就 step11 而言，指针必须对齐到 4 字节边界。 11.8. 只要指针类型和被指向的对象的类型不匹配，空指针除外，就是未定义行为，哪怕没有解引用。 所以 int a; int *p = (int*)a; 包含了未定义行为。 "},"docs/lab12/part0-intro.html":{"url":"docs/lab12/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab12/part4-codegen.html":{"url":"docs/lab12/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 数组定义 数据的内存空间是连续的，因此无论数组的原型是几维的，都可以看做是一个一维的大数组。例如，对于一个数组 int a[d1][d2]⋯[dn]\\mathtt{int}~a[d_1][d_2]\\cdots[d_n]int a[d​1​​][d​2​​]⋯[d​n​​]，可看做是 int a′[d1d2⋯dn]\\mathtt{int}~a'[d_1d_2\\cdots d_n]int a​′​​[d​1​​d​2​​⋯d​n​​]。访问 a[i1][i2]⋯[in]a[i_1][i_2]\\cdots[i_n]a[i​1​​][i​2​​]⋯[i​n​​]，就是访问 a′[i1d2d3⋯dn+i2d3d4⋯dn+⋯+in]a'[i_1d_2d_3\\cdots d_n + i_2d_3d_4\\cdots d_n + \\cdots + i_n]a​′​​[i​1​​d​2​​d​3​​⋯d​n​​+i​2​​d​3​​d​4​​⋯d​n​​+⋯+i​n​​]。 我们需要考虑定义数组时，是作为局部变量还是全局变量： 当某个局部变量定义为数组时，数组空间分配在栈上。这与普通变量的定义基本没区别，同样需要算出在栈帧上的偏移量，只不过大小不再是固定的 4 字节，而是数组的元素个数再乘 4 (字节/元素)，因此计算其他变量的偏移量时也要做相应修改。由于不支持数组的初始化，分配完栈帧后不用管它就行，即使这段栈空间保留了之前变量的信息，因此数组还有其他未初始化的局部变量的初值都是不确定的。 当某个全局变量定义为数组时，数组空间分配在程序的数据段。同样我们不考虑 BSS 段，直接将其放到 .data 中。作为全部变量时，数组中每个元素默认初始化为 0，可用如下汇编码来将连续一段内存初始化为 0： .align 2 a: .zero 400 其中 .zero 后面的数字即这段内存的大小（单位字节）。上述汇编码可由定义在全局的 int a[100]; 或 int a[10][10]; 生成。 在 RISC-V 指令集中，addi、lw、sw 等 I 型和 S 型指令的立即数大小只有 12 位，因此我们不能定义一个很大的数组作为局部变量，否则那些分配栈帧、Load/Store 局部变量的指令的偏移量就会超出 12 位。你可以实现对这种情况的特殊处理，使用其他指令进行代替，不过我们的测试集保证了不会出现这种情况。 下标运算 指针下标 我们允许对指针和数组类型进行下标运算。首先来看指针的下标运算。指针的下标运算非常类似于解引用运算 *，只是需要加上一个偏移，大小为下标乘上指针基类型的大小，即 p[i] 等价于 *(p + i * size)。另外需要注意，我们在 lab11 中提到了左值的概念，* 运算后的结果可以是左值，类似地，指针的下标运算也可以是左值： int *p; p[0] = 1; // p[0] 是左值 int a = p[1]; // p[1] 是右值 int *q = &p[2]; // p[2] 是左值 于是，我们按照实现解引用运算的方法，即可实现指针的下标运算。 数组下标 然后再来看数组的下标运算。数组的下标运算可以分为两类： 当下标运算的次数等于数组的维度时，结果是数组中的元素。这种情况与指针的下标运算类似，可以作为右值，结果是数组中元素的值；也可以作为左值，结果是数组中元素的地址。 当下标运算的次数小于数组的维度时，结果是一个数组。由于任何数组可看做一个一维大数组，此时的结果也可以看做是原数组中的一个子数组。当之后对该结果进行转指针、取下标等运算时，都是相对于这个子数组来说的。之后要取子数组中的哪个元素现在还是未知的，因此无论之后是否有可能成为左值，这一步都应该返回子数组的地址。 对于第 1 种情况，与指针的下标运算类似处理；对于第 2 种情况，关键是要求出子数组的地址。由于下标运算在文法中是递归定义的，我们可以自然地得出地址的计算方法： 对于数组类型的变量 Ident，地址即 Ident 在栈或数据段的地址； 对于子数组 array[i]，地址是 array 的地址加上 i * sizeof(array[i])。 例如，对于数组 int a[3][4][5]，有： a[i] 的地址是 a + (i * 4 * 5) * sizeof(int)； a[i][j] 的地址是 a + [(i * 4 * 5) + (j * 5)] * sizeof(int)； a[i][j][k] 的地址是 a + [(i * 4 * 5) + (j * 5) + k] * sizeof(int)。 总结一下，无论是指针还是数组，无论是左值还是右值，我们都可以用同一套代码框架来生成汇编码： function visitSubscript(ctx) { // ::= '[' expr ']' visitPostfix(postfix); // 计算要取下标的表达式的值，设结果保存在 t0 visitExpr(expr); // 计算下标的值，设结果保存在 t1 emitMul(\"t1\", \"t1\", ctx.type.size); // t1 = t1 * sizeof(结果的类型) emitAdd(\"t0\", \"t0\", \"t1\"); // t0 = t0 + t1，此时的结果即下标运算后子数组或元素的地址 if (ctx.type == Array || ctx.isLValue) { // do nothing // 如果结果是数组类型，或是左值，直接返回其地址 } else { emitLoad(); // 否则，再生成一条 Load 指令来取出该地址中保存的值 } } function visitPrimary(ctx) { if (ctx ::= Ident) { // ::= Identifier emitAddress(Ident); // 计算变量 Ident 的地址 if (ctx.type == Array || ctx.isLValue) { // do nothing // 如果变量是数组类型，或是左值，直接返回其地址 } else { emitLoad(); // 否则，再生成一条 Load 指令来取得变量的值 } } else { // ... } } 指针算术运算 这一步非常简单，我们要支持的所有指针算术运算就这么多： 指针加整数，或整数加指针：只需增加一步，将整数操作数乘上指针基类型的大小。 指针减整数：与指针加法一样，只需增加一步，将整数操作数乘上指针基类型的大小。 指针减指针：先直接做减法，然后除以指针基类型的大小（要求两指针基类型相同）。 由于指针的基类型只能是 int 或指针，其大小都是 4 字节，你可以用 slli、srai 指令进行左移、右移来代替乘除运算。 "},"docs/lab12/part4-1-task.html":{"url":"docs/lab12/part4-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新汇编代码生成过程，以正确处理数组类型、下标运算以及指针算术运算。并通过 step[1-12] 的测试用例。 恭喜你通过自己的努力，完成了 minidecaf lab1-lab12，从零开始实现了一个自己的编译器！ "},"docs/lab12/summary.html":{"url":"docs/lab12/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab12/spec.html":{"url":"docs/lab12/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step12 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' | type '*' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | unary '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!'|'&'|'*') unary | '(' type ')' unary postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' primary : Integer | '(' expression ')' | Identifier step12 语义规范 12.1. 支持多维数组，但每一维长度只能是正整数常数，不能是零或负数。 所以也没有变长数组 int a[n]; 也没有不定长数组 int a[];。 12.2. 对数组取地址是错误，也不会有指向数组的指针。 这是为了简化实验，否则需要引入 C 中一堆繁复的记号，像 int *a[10] 和 int (*a)[10]，对于实验意义不大。 12.3. 数组声明不能有初始值。局部变量数组初始值未定，全局变量初始值为零。 C 中可以写 int a[2]={1, 2} 但 MiniDecaf 不行。 12.4. 数组首地址对齐要求同元素的对齐要求（4 字节）。 数组的各个元素在内存中是连续的，并且多维的情况下排在前面的维度优先。 例如 int a[3][4][5] 占用了 60 个 int（240 字节）的连续内存，和 int b[60] 一样。 a[1][2][3] 的偏移量是 (1*20+2*5+3) * 4 字节，和 b[33] 一样。 12.5. 下标运算优先级高于一元运算符。 因此 -a[0] 即 -(a[0])。 12.6. 下标运算 a[b] 的操作数类型必须是：a 为指针或数组，b 为 int。 12.7. 下标运算越界是未定义行为。 12.8. 可以将数组的前几维单独提出，类型还是数组类型，可转换以后赋给一个指针。 例如 int a[2][2][2]，那么 int *p = (int*) a[0]; int *q = (int*) a[1][1]; 是合法的。 但 int x=a[1] 和 int *r=a[0][0][0] 是不合法的。 12.9. 左值表达式除了能通过 11.1 中三条规则得到，新增一条规则： 通过下标运算，如果结果类型不是数组类型，那么结果表达式是左值。 例如 int a[2][2]，那么 a[1] 不是左值，但 a[1][1] 是左值，a[1][1]=2 和 &a[1][1] 都是合法操作。 12.10. 数组类型的表达式仅能参与如下运算：类型转换、下标。 12.11. 函数形参不能被声明为数组，传参只能传指针。 C 允许 int foo(int a[]); 和 int bar(int b[5]); 但我们不允许。 12.12. （更新 11.5）指针可参加加减运算，允许 int 加指针和指针加 int，以及指针减 int（不允许 int 减指针）。 运算结果的类型和指针操作数的类型相同。 实际运算时，int 操作数需要乘上指针基类型的大小。 例如 int **p（考虑到 sizeof(int*) == 4），那么 p-2 等价于 p+-2，其汇编类似 addi result, p, -8。 12.13.（更新 11.5）允许两个指针相减，但两个指针类型必须相同。 a 和 b 是同类型的指针，那么 a-b 的结果 c 是一个 int，且满足 a == b+c。 12.14. 空指针参与任何指针算术都是未定义行为。 12.15. 指针运算越界，按照 11.8 是未定义行为。但有特例：允许越界一个元素。 例如如下代码是合法的 int a[10]; int *p=(int*) a; for (int *q=p; q != p+10; q=1+q) *q=0; 哪怕其中 p+10 已经越界了。 "},"REFERENCE.html":{"url":"REFERENCE.html","title":"参考资料","keywords":"","body":"参考资料 Writing a C Compiler: by Nora Sandler An Incremental Approach to Compiler Construction : by Abdulaziz Ghuloum "}}