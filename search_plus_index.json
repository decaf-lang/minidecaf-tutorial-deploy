{"./":{"url":"./","title":"实验简介","keywords":"","body":"minidecaf-tutorial "},"docs/log.html":{"url":"docs/log.html","title":"更新日志","keywords":"","body":"更新日志 "},"docs/lab0/part0-intro.html":{"url":"docs/lab0/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab0/part2-testing.html":{"url":"docs/lab0/part2-testing.html","title":"测试","keywords":"","body":"测试 你可以修改minidecaf测试中的自动批量测试脚本，来测试你的编译器是否正常通过所有step1测试用例。它将使用你的编译器编译一组测试程序，执行它们，并确保它们返回正确的值。 为了用脚本自动批量测试一组程序，你写的编译器需要遵循这个规范。 它可以从命令行中调用，只需要一个C源文件作为参数，例如：1: ./YOUR_COMPILER /path/to/program.c。 当传入program.c时，它会在同一目录下生成program.s汇编代码文件。 如果解析失败，它不会生成汇编代码文件。 脚本不会检查你的编译器是否输出合理的错误信息。 "},"docs/lab0/summary.html":{"url":"docs/lab0/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab1/part0-intro.html":{"url":"docs/lab1/part0-intro.html","title":"摘要","keywords":"","body":"Lab1：整数 这是关于编写minidecaf编译器的第一个步骤。 编写minidecaf编译器是参考了使用Abdulaziz Ghuloum的An Incremental Approach to Compiler Construction和Nora Sandler的Writing a C Compiler作为路线图。这里的minidecaf语言基本上是C语言的一个子集。你通过从编译minidecaf源语言的一个微不足道的子集开始，能够生成RISC-V汇编代码，并能在RISC-V机器（目前是基于QEMU模拟器）上运行/测试你写的编译器生成的最终机器代码。然后你再一步一步地添加新的语言特性。在第一步中，你只是返回常量；在后面的步骤中，你处理加法和减法；以此类推。每一步都小到足以让人感觉到易于管理，而在每一步结束时，你都有一个可以工作的编译器。另外，通过足够详尽的测试程序，你可以随时验证你的编译器在每次更新后是否正常工作。 前言 在你开始之前，你需要决定两件事：用什么语言来写你的编译器，以及如何处理词法分析（lexing）和语法解析（parsing ） 。你可以用任何你喜欢的语言来实现编译器 提示：建议使用具有和sum type和模式匹配（ pattern matching）的语言，比如OCaml、Haskell或Rust。如果你这样做的话，构建和遍历一个AST会变得更加简单。前提是你能接受学习和掌握这些编程语言的所投入的时间与精力。 你还需要决定是自己写语法解析器和词法分析器，还是使用自动解析器和扫描器生成器（例如flex，bison，antlr4）。在整个实验环节中，两种方式都会提供。我们将展示如何手工编写一个词法器（或扫描器）和递归下降解析器。使用解析器生成器可能更容易，缺点是了解底层运行细节和调试bug可能会困难一些。如果能够直接设计实现解析器生成器，那么对编译课上讲的很多原理、算法的理解会更加深入。 注意：设计实现解析器生成器不是基本实验要求。 本阶段我们将编译一个返回单个整数的minidecaf程序。我们还将建立编译器的三个基本阶段（pass）：词法、解析和代码生成。。第一步将有比较大的工作量，即建立了一个编译器的框架，该框架将使以后添加更多语言特性变得容易，对后续实验步骤有较大的帮助， 下面是一个我们要编译的程序 return_2.c int main() { return 2; } 我们将只处理有一个函数 \"main \"的程序，它由一个返回语句组成。唯一不同的是返回的整数的值，我们不会处理十六进制或八进制的整数，只处理十进制。我们不会处理十六进制或八进制的整数，只处理十进制。为了验证你的编译器是否正常工作，你需要编译一个程序，运行它，并检查它的返回代码。 $ YOUR_COMPILER return_2.c # 用例的编译器会把return_2.c编译为 return.s 汇编程序 $ riscv64-unknown-elf-gcc return_2.s -o return_2 # riscv-64汇编器把return.s翻译为return_2执行程序 $ qemu-riscv64 ./return_2 # 用QEMU for riscv-64硬件模拟器运行return_2执行程序 $ echo $? # 检查return_2执行程序的执行结果，应该是 2 2 你的编译器会产生risc-v汇编代码。我们不会自己将汇编文件转化为可执行文件--那是汇编器和链接器的工作（最好有个链接介绍汇编器和连接器）。为了看看这个程序在汇编中的样子，让我们用GCC来编译它。 $ riscv64-unknown-elf-gcc -S -O3 return_2.c $ cat return_2.s .file \"return_2.c\" ...... .globl main .type main, @function main: li a0,2 ret ...... 现在，让我们看看汇编程序本身。我们可以忽略.section、.align等指令，这些汇编原语可参加这里的介绍。--如果你删除它们，你仍然可以生成并运行return_2执行程序。.globl main表示main符号应该对链接器可见，否则它找不到程序的入口点。 最后，我们有了实际的汇编指令。 main: ; label for start of \"main\" function movl $2, %eax ; move constant \"2\" into the a0 register ret ; return from function 这里最重要的一点是，当一个函数返回时，a0寄存器将包含其返回值。main函数的返回值将是程序的退出代码。在上面的汇编片段中，唯一可以改变的是返回值。 注意：每当你在阅读汇编时，请确保你知道它使用的是什么语法! "},"docs/lab1/part1-lex.html":{"url":"docs/lab1/part1-lex.html","title":"词法分析","keywords":"","body":"词法分析 词法分析器（也叫扫描器或标记器）是编译器的一个阶段，它将一个字符串（源代码）分解成一个标记列表（token list）。一个标记（token）是语法解析器（parser）能够理解的最小单位--如果一个程序就像一个段落，那么标记就像一个个单词(许多标记是用空格隔开的独立的单词)。变量名（variable names）、关键字（keywords）、常量（constants）以及像括号（braces）这样的标点符号都是标记的例子。下面是 return_2.c 中所有标记的列表。 int keyword Identifier “main” Open parentheses Close parentheses Open brace return keyword Constant “2” Semicolon Close brace 注意，有些标记有一个值 (例如常量(constant)标记的值是 \"2\")，有些则没有 (如括号和大括号)。 下面是词法分析器（lexer）需要识别的所有标记，以及定义每个标记的正则表达式（regular expression）。 Open brace { Close brace } Open parenthesis \\( Close parenthesis \\) Semicolon ; Int keyword int Return keyword return Identifier [a-zA-Z]\\w* Integer literal [0-9]+ 提示：你也可以直接使用 \"keyword\"这样统一的一个标记类型（token type），而不是为每个关键词使用不同的标记类型。 ☑任务： 写一个lex函数，接受一个文件并返回一个标记列表。它应该适用于minidecaf测试用例中的所有step1中的示例。为了保持简单，我们只对十进制整数进行词法分析。如果你愿意尝试，你也可以扩展你的词法分析器来处理八进制和十六进制整数。 注意：我们不能对负整数进行词法分析。这并不是偶然的--C 语言没有负整数常量。它只是有一个负一元运算符，可以应用于正整数。我们将在下一步添加负一元运算。 "},"docs/lab1/part1-1-task.html":{"url":"docs/lab1/part1-1-task.html","title":"任务","keywords":"","body":"☑任务： 你可以选择编写一个函数，接受一个输入字符串并返回一个标记列表；或者编写一个相关的类，用字符串来构造它，其中包含一些必要的状态，从而可以让一个成员函数每调用一次返回一个标记。 如果你选择使用的是flex这样的语法分析工具，它自动生成的文件可能是一个依赖于很多全局变量的函数，也能做到每调用一次返回一个标记；此外它可能是接受一个输入的文件，而不是输入的字符串，显然如果我们要自己实现的话还是接受字符串更简单一些。其实这些与上面描述的也没有本质的区别。 你编写的类或者函数应该可以正确处理minidecaf测试用例中step1中的所有测例。 注意：根据step1的spec，我们不能处理return负整数的程序。这并不是偶然的--C语言没有负整数常量，它只是有一个可以应用于正整数的负号运算符，这是下一步的工作了。 "},"docs/lab1/part2-parse.html":{"url":"docs/lab1/part2-parse.html","title":"语法分析","keywords":"","body":" 注意：我们不能对负整数进行词法分析。这并不是偶然的--C 语言没有负整数常量。它只是有一个负一元运算符，可以应用于正整数。我们将在下一步添加负一元运算。 语法解析 下一步是将我们的标记列表转化为抽象的语法树（Abstract Syntax Tree，简称AST）。AST是表示程序结构的一种方式。在大多数编程语言中，像条件和函数声明这样的语言结构是由更简单的结构组成的，比如变量和常量。AST捕捉到了这种关系；AST的根将是整个程序，而每个节点将有子节点代表它的组成部分。让我们来看一个小例子。 if (a 这段代码是一个if语句，所以我们将AST的根标记为 \"if statement\"。它有三个子节点： 表达式：condition (a ) 语句列表：if body (c = 2; return c;) 语句列表：else body (c = 3;) 这些节点都可以进一步分解。例如，condition (a )表达式是一个有两个操作数（operand ）子节点的\"二元操作的AST节点： first operand (variable a) second operand (variable b) 一个赋值语句（如c=2;）也有两个子节点：被更新的变量（c）和赋值给它的表达式（2）。 另一方面，if body是语句列表，它可以有任意数量的子节点--每个语句都是一个子节点。在本例中，它有两个子节点，因为有两条语句。这些子节点是有序的--c=2;排在return c;之前，因为在源代码中就是这样按序排列的。 下面是这段代码的完整AST： if statement condition: binary operation ( operand 1: variable a operand 2: variable b if body: statement list statement 1: assignment variable: c right-hand side: constant 2 statement 2: return return value: variable c else body: statement list statement 1: assignment variable: c right-hand side: constant 3 而这里是构造这个AST的伪代码： //create if condition cond = BinaryOp(op='>', operand_1=Var(a), operand_2=Var(b)) //create if body assign = Assignment(var=Var(c), rhs=Const(2)) return = Return(val=Var(c)) if_body = [assign, return] //create else body assign_else = Assignment(var=Var(c), rhs=Const(3)) else_body = [assign_else] //construct if statement if = If(condition=cond, body=if_body, else=else_body) 不过现在我们不需要担心条件（conditionals）、变量赋值（variable assignments）或二进制操作符（binary operators）。现在，我们需要支持的AST节点只有程序（programs）、函数声明（function declarations）、语句（statements）和表达式（expressions）。下面是我们对return_2.c给出的AST节点的定义： program = Program(function_declaration) function_declaration = Function(string, statement) //string is the function name statement = Return(exp) exp = Constant(int) 现在，一个程序由一个函数main组成。在后面的步骤中，我们将把一个程序定义为一个函数列表。一个函数有一个名称（name）和一个函数体（body）。以后，一个函数还会有一个参数列表（list of arguments）。在实际的编译器中，我们还需要存储函数的返回类型（return type），但现在我们只有整数类型。函数体中只包含一条单一的语句（后续会扩展为语句列表）。语句的类型只有一种：返回语句（return statement）。以后我们会增加其他类型的语句，比如条件（conditionals）和变量声明（variable declarations）。一个返回语句有一个子语句，即表达式--这就是被返回的值。现在一个表达式只能是一个整数常量。以后我们会让表达式包含算术运算，这将使我们能够解析像return 2+2;这样的语句。 当我们添加新的语言结构时，我们会更新AST节点的定义。例如，我们最终会添加一种新的语句类型：变量赋值。当我们这样做的时候，我们会在我们的statement定义中添加一个新的形式。 statement = Return(exp) | Assign(variable, exp) 这里是return_2.c的AST图。 最后，我们需要一个形式化的语法，它定义了一系列标记如何组合成语言构造。我们将基于Backus-Naur Form来定义： ::= ::= \"int\" \"(\" \")\" \"{\" \"}\" ::= \"return\" \";\" ::= 上面的每一行都是一个产生式（production ），定义了如何从一种形式语言（BNF）的构造和标记来建立另外一个语言（minidecaf）的构造。每一个出现在产生式左侧的符号（即、、）都是一个非终结符（non-terminal symbol）。个别标记（keywords、id、punctuation等）是终结符（terminal symbols）。请注意，虽然这个语法告诉我们什么样的标记序列构成了一个有效的minidecaf程序，但它*没有告诉我们到底如何将这个程序转化为AST--例如，在AST中没有对应Constant节点的产生式。我们可以重写我们的语法，让常量有一个产生式，但这不是必须的。 现在的语法非常简单，每个非终结符只有一条产生式。在后续试验中，一些非终结符将有多个产生式。例如，如果我们增加了对变量声明的支持，我们就可以有以下的产生式。 ::= \"return\" \";\" | \"int\" \"=\" \";\" "},"docs/lab1/part2-1-rdp.html":{"url":"docs/lab1/part2-1-rdp.html","title":"递归下降分析","keywords":"","body":"递归下降解析 为了将一个标记列表转化为AST，我们将使用一种叫做递归下降解析的技术。我们将定义一个函数来解析语法中的每个非终结符，并返回一个相应的AST节点。解析符号S的函数应该从列表的开头删除标记，直到它到达S的有效派生。如果在它完成解析之前，碰到了一个不在S的产生式中的标记，它应该失败。如果 S 的产生式规则包含其他非终结符，它应该调用其他函数来解析它们。 下面是解析语句的伪代码。 def parse_statement(tokens): tok = tokens.next() if tok.type != \"RETURN_KEYWORD\": fail() tok = tokens.next() if tok.type != \"INT\" fail() exp = parse_exp(tokens) //parse_exp will pop off more tokens statement = Return(exp) tok = tokens.next() if tok.type != \"SEMICOLON\": fail() return statement 后面可以发现，产生式是递归的（例如一个算术表达式可以包含其他表达式），这意味着解析函数也将是递归的--因此这种技术被称为递归下降解析。 "},"docs/lab1/part2-2-task.html":{"url":"docs/lab1/part2-2-task.html","title":"任务","keywords":"","body":"☑任务： 编写一个parse函数，接受一个标记列表，并返回一个AST，根节点（root node）是Program节点。该函数应该为所有有效的step1测试用例建立正确的AST。如果你愿意，你也可以让你的解析器在遇到超过INT_MAX（整数最大值）的整数常量时优雅地失败并指出解析失败的原因。 有很多方法可以在代码中表示AST--每种类型的节点可以是它自己的类或它自己的数据类型，这取决于你用什么语言来编写编译器。例如，以下是你如何将AST节点定义为数据类型伪代码： type exp = Const(int) type statement = Return(exp) type fun_decl = Fun(string, statement) type prog = Prog(fun_decl) "},"docs/lab1/part3-ir.html":{"url":"docs/lab1/part3-ir.html","title":"中间码","keywords":"","body":"中间代码生成 IR IR也是表示程序结构的一种方式，一般来说IR比AST更加接近汇编，但是仍然保存了一些程序中的高级信息，因此比汇编更加容易优化。 IR有很多种类，包括三地址码(Three Address Code, TAC)，静态单赋值形式(Static Single Assignment Form, SSA)，基于栈的IR，等等。如果你感兴趣的话可以自行查阅了解，这里不做要求。 我们这里使用基于栈的IR。这种IR的最大特点是中间代码生成和汇编代码生成(不追求性能的话)非常容易编写，但是一般实际的编译器都不会使用它，因为它并不适合进行优化，这样其实也就失去了IR存在的根本意义之一了。 类似Java Bytecode这样的，虽然也可以看做是基于栈的IR，但是实际的Java虚拟机中都会先把它转化成其它容易优化的形式，所以它的意义仅仅是便于生成和传输，不会用于汇编代码生成。 尽管如此，我们这个教学用的编译器还是选择使用基于栈的IR，主要目的是能够体现IR这个结构在实际的编译器中的地位，尽量让大家体会感受编译器的工作流程，只是限于课程的工作量的限制还是没法和实际的编译器做到真正的一致。 基于栈的IR顾名思义维护一个运算栈，它最主要的特点在于它的运算指令，例如加法和减法指令这些，是没有操作数的。所有的运算指令的语义都是从这个运算栈的顶部弹出操作数，进行运算后再把结果压回栈中。这里不能完全理解也没有关系，我们之后每加入新的指令时都会介绍其功能和特点。 本阶段用到的指令 现在唯一可能的语句是return一个常数，所以IR中完全可以只设计一条指令，也就是return一个常数，这个常数也作为指令的一部分。但是我们不推荐这样的设计，因为这样完全无法兼容后面的新语法，之后可以return一个变量之后，这条return常数的指令事实上是完全用不上了，所以反而总工作量还变大了。 我们的建议是设计两条指令： PUSH指令，指令中还包含一个常数，语义是将这个常数压入栈中 RET指令，语义是将栈顶的值弹出，将这个值作为返回值结束程序 对于一条return常数的指令，就依次生成这两条指令即可。 "},"docs/lab1/part3-1-task.html":{"url":"docs/lab1/part3-1-task.html","title":"任务","keywords":"","body":"任务 编写一个函数，将AST中的main函数转化为一段指令序列。因为本阶段程序中只可能有一个函数，所以其实在IR的层面也不需要有函数的概念，整个程序就是一段指令序列。 "},"docs/lab1/part4-codegen.html":{"url":"docs/lab1/part4-codegen.html","title":"代码生成","keywords":"","body":"汇编代码生成 我们选择的目标平台是RISC-V 64，我们可以先看看常见的编译器生成的汇编代码是什么样的： $ riscv64-linux-gnu-gcc return2.c -S -O3 $ cat return2.s .file \"return2.c\" .option nopic .text .section .text.startup,\"ax\",@progbits .align 1 .globl main .type main, @function main: li a0,2 ret .size main, .-main .ident \"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0\" 其实这里有很多多余的信息，你可以自己尝试一下，只留下最关键的一些表示main函数的信息就可以经由汇编器和链接器生成正确的程序： .globl main main: li a0,2 ret 这里做的事情倒是很直接，就是直接return一个常数了，不过跟我们上面描述的两条指令做到事情还是不太一样。为了能够模拟我们描述的PUSH和RET的操作，还是有必要了解一下RISC-V指令集和相关的调用约定的知识，不过为了减小大家的工作量，这个阶段我们不要求你们去自行查阅，而是把必要的知识都列出来： 我们假定整数都是64位的，因此运算栈中的一个元素占据8字节 我们可以用sp寄存器来表示栈，sp的值就是栈顶，但是这个栈是向地址低的地方生长的，所以如果sp的值减少8，就意味着栈增长了一个元素 我们可以用t开头的寄存器来进行一些临时的数据存储和运算 最终函数的返回值需要保存到a0寄存器中 li指令用来加载一个常数到寄存器中，sd指令用来把一个寄存器中的值保存到一个内存地址，ld指令用来把一个内存地址中的值读入到一个寄存器，ret用来执行函数返回 所以，对于一条PUSH指令，可以生成这样的代码： li t0, # 用t0临时存储这个常数 sd t0, -8(sp) # 把t0中的值保存在栈顶后的一个元素的位置 add sp, sp, -8 # 栈增长一个元素，这一条和上面一条合起来就是压入一个元素 对于一条RET指令，可以生成这样的代码： ld a0, 0(sp) # 从栈顶读出值到表示返回值的寄存器 add sp, sp, 8 # 栈减小一个元素，这一条和上面一条合起来就是弹出一个元素，并把值赋给a0 ret # 函数返回 最终你为return2.c生成的整个汇编程序可以是这个样子的： .globl main main: li t0, 2 sd t0, -8(sp) add sp, sp, -8 ld a0, 0(sp) add sp, sp, 8 ret "},"docs/lab1/part4-1-task.html":{"url":"docs/lab1/part4-1-task.html","title":"任务","keywords":"","body":"☑任务： 写一个generate函数，接受一个AST并生成汇编。它可以以字符串的形式在屏幕上显示汇编代码，也可以直接把汇编代码写到文件中。它应该为所有step1测试用例生成正确的汇编码。 ☑ 任务：写一个pretty-print funcion，它接收一个AST并以可读的方式打印出来。 写一个pretty-print的函数，接受一个AST并以可读的方式打印出来。 (可选) 漂亮的打印 你可能需要一个实用函数来打印出你的AST，以帮助调试。你可以现在就写，或者等到你需要的时候再写。下面是对return_2.c的AST输出例子： FUN INT main: params: () body: RETURN Int 这个例子包含了一些AST不需要的信息，比如返回类型和函数参数列表。 ☑任务： 编写一个接受C源文件并输出可执行文件的程序（可以是一个包含调用你写的编译器和GCC的shell脚本）。该程序应该 读取minidecaf源文件 进行词法分析 进行语法解析 生成汇编码 把汇编码写入到一个文件 调用GCC命令，将生成的汇编码转换为可执行文件。在下面命令中，\"assembly.s \"是汇编文件的名称，\"out \"是你想生成的可执行文件的名称。 riscv64-unknown-elf-gcc assembly.s -o out (可选) 删除汇编文件。 "},"docs/lab1/summary.html":{"url":"docs/lab1/summary.html","title":"小结","keywords":"","body":"下一步 在下一步中，我们将增加三个单数运算符。-、~和！。 参考 An Incremental Approach to Compiler Construction Writing a C Compiler "},"docs/lab2/part0-intro.html":{"url":"docs/lab2/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab2/summary.html":{"url":"docs/lab2/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab3/part0-intro.html":{"url":"docs/lab3/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab3/summary.html":{"url":"docs/lab3/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab4/part0-intro.html":{"url":"docs/lab4/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab4/summary.html":{"url":"docs/lab4/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab5/part0-intro.html":{"url":"docs/lab5/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab5/summary.html":{"url":"docs/lab5/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab6/part0-intro.html":{"url":"docs/lab6/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab6/summary.html":{"url":"docs/lab6/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab7/part0-intro.html":{"url":"docs/lab7/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab7/summary.html":{"url":"docs/lab7/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab8/part0-intro.html":{"url":"docs/lab8/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab8/summary.html":{"url":"docs/lab8/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab9/part0-intro.html":{"url":"docs/lab9/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab9/summary.html":{"url":"docs/lab9/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab10/part0-intro.html":{"url":"docs/lab10/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab10/summary.html":{"url":"docs/lab10/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab11/part0-intro.html":{"url":"docs/lab11/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab11/summary.html":{"url":"docs/lab11/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab12/part0-intro.html":{"url":"docs/lab12/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab12/summary.html":{"url":"docs/lab12/summary.html","title":"小结","keywords":"","body":"小结 "}}